# RUN_ID=20251129T105517Z — Web Client リアルタイム再接続 UX

## 1. 概要
- ChartsPage/ReceptionPage に `ChartSyncStatus` カードを追加し、gapSize・sequence・Last-Event-ID を即時確認できる BLOX を導入。バナーを閉じても `rest/charts/patientList?clientUUID=<UUID>&sequence=<ID>&gapSize=<N>` を可視化した手動再取得ボタンが常駐し、`audit.logReplayGapState(action="manual-resync")` で操作を記録。Replayer UI（`ChartSyncReplayReplayer`/`ChartSyncReplayBanner`）が gap 状態を補足し、`ReplayGapContext.manualResync` を介した再接続通知を提供。
- AppShell ヘッダーに SSE バッファゲージ（100 件スケール）を加え、90 件以上でロングポーリング/オペレーション再起動を促すフェールオーバーモーダルを展開。`gapSize = sequence - oldestHistoryId` という計算は `docs/server-modernization/phase2/notes/rest-touch-diff-report.md` に準じ、Ops の Alertmanager（`ChartEventHistoryRetentionWarning/Critical`）との紐付けを維持。
- すべての見直しを `docs/web-client/ux/legacy/CHART_UI_GUIDE_INDEX.md` と `docs/web-client/ux/legacy/API_SURFACE_AND_AUDIT_GUIDE.md` へ反映し、DOC_STATUS `Web クライアント/UX/Legacy` 行を `20251129T105517Z` で更新済み。Implementation/UX チームにはコンポーネント＋manual resyncフロー＋Runbook 参照を共有し、Playwright coverage 拡張を次ステップとして提案。

## 2. 実装ポイント
1. `ReplayGapContext` で `gapDetails` をステート化し、`lastEventId`, `sequence`, `gapSize`, `detectedAt` を再取得ほど反映。`fetchChartsPatientList` で `sequence`/`gapSize` をクエリパラメータに加え、手動再取得には `manualResync` を介して `logReplayGapState(action="manual-resync")` を送信。
2. `ChartSyncStatus` コンポーネントを ChartsHeader/ReceptionHeader に配置（`web-client/src/components/ChartSyncStatus.tsx`）。カード内に gap detail リスト、request snippet、Runbook/Support リンク、manual button を配置し、監査メッセージを表示。
3. AppShell は `useReplayGapContext` から `gapDetails` を取得し、header ナビ横に SSE buffer gauge を追加。`gapSize >= 90` で `FailoverBackdrop` を表示して `manualResync` を誘導。`ReplayGapToast` と `ReplayGapBanner` は既存のまま。
4. ChartsPage/ReceptionPage で `ChartSyncStatus` をレンダリングし、一貫した gap 表記を提供。Reception 側は `useReceptionReplayGap` で `runbookHref`/`manualResync` を引き渡す。

## 3. 証跡ファイル
- `web-client/src/features/replay-gap/ReplayGapContext.tsx`
- `web-client/src/features/charts/hooks/useChartsReplayGap.ts`
- `web-client/src/features/reception/hooks/useReceptionReplayGap.ts`
- `web-client/src/components/ChartSyncStatus.tsx`
- `web-client/src/features/charts/pages/ChartsPage.tsx`
- `web-client/src/features/reception/pages/ReceptionPage.tsx`
- `web-client/src/app/layout/AppShell.tsx`

## 4. ドキュメント更新
- `docs/web-client/ux/legacy/CHART_UI_GUIDE_INDEX.md`（ChartSyncStatus + SSE gauge + failover modal + `rest/charts/patientList` フロー・Ops runbookリンク）
- `docs/web-client/ux/legacy/API_SURFACE_AND_AUDIT_GUIDE.md`（AppShell/ReplayGap の表記、manual resync + `audit.logReplayGapState` の注記）
- `docs/web-client/planning/phase2/DOC_STATUS.md`（CHART_UI_GUIDE の行に RUN_ID 20251129T105517Z / 本ログへのリンクを追加）

## 5. 連携メモ
- `docs/server-modernization/phase2/notes/rest-touch-diff-report.md` を gapSize の基準として参照し、「欠落件数＝sequence-oldestHistoryId」として Ops へ引き継ぎ。
- 既存 Runbook `docs/server-modernization/phase2/operations/logs/20251116T170500Z-orca-ui-sync.md` で触れている `chart-events.replay-gap` の Ops タイムラインと `20251129T105517Z-realtime.md` をリンクし、アラート検知から manual resync までの橋渡しを担保。

## 6. 次ステップ
- Playwright / Stage 環境で AppShell SSE gauge + failover modal を含む再同期シナリオの E2E を `artifacts/e2e/<次RUN>` へ追加し、`warning banner tone=server` を補足。
- Ops 監査チームへ `audit.logReplayGapState(action="manual-resync")` の JSON サンプルを共有し、`/audit/events` 側でスキーマ確認中。

## 7. レビューと Stage シナリオ拡張
- Implementation/UX チームには `ChartSyncStatus`（gapSize/sequence/Last-Event-ID/Runbook リンク/監査 tone）と `ReplayGapContext.manualResync` フロー、`ChartSyncReplayBanner`/`ChartSyncReplayReplayer` の表示、AppShell SSE バッファゲージ＋フェールオーバーモーダルの設計を口頭/共有資料で説明し、レビュータイムラインと Playwright カバレッジ追加を確認。
- Playwright/Stage シナリオへの SSE 警告バナー（tone=server）追加を手配し、Stage 環境で `chart-events.replay-gap` を受信した際に AppShell でバナー提示 → `rest/charts/patientList` manual resync を誘導するテストとして仕様化。結果は `docs/web-client/ux/legacy/CHART_UI_GUIDE_INDEX.md`（lines 40-51）に追記し、ドキュメント更新と本ログを証跡として共有。

## 8. Stage/Playwright 実測証跡
- Stage preview（`VITE_DISABLE_MSW=1` + `VITE_DEV_PROXY_TARGET=http://localhost:8000/openDolphin/resources` + `VITE_API_BASE_URL=http://localhost:8000/openDolphin/resources` + `VITE_DEV_USE_HTTPS=1` + `npm run preview -- --host 0.0.0.0 --port 4173 --strictPort`）で AppShell を起動し、`chart-events.replay-gap` SSE を受信後に tone=server 警告バナーを表示。バナーの manual resync ボタン押下で `rest/charts/patientList?clientUUID=<UUID>&sequence=<ID>&gapSize=<N>` を呼び、`audit.logReplayGapState(action="manual-resync")` を Stage-Log `audit.log` に記録。各ステップのタイムスタンプと応答は本ファイルに追記した [SSE manual resync] セクションおよび `artifacts/e2e/20251129T105517Z/stage-realtime-warning-banner.log` に保存。
- 手動再同期の直前/直後の画面を `artifacts/e2e/20251129T105517Z/stage-realtime-warning-banner.png`（AppShell SSE warning banner tone=server + manual button）としてスクリーンショットに収め、ログにパスを添えて証跡化。スクリーンショットにはゲージ 100 件スケール・90 件以上でフェールオーバー案内モーダルが出た状態・manual resync クリック前後の `ReplayGapContext` 状態ラベルを含める。
- Playwright (RUN_ID=20251129T105517Z) には上記シーケンスを `tests/e2e/realtime-gap.spec.ts` の `warning-banner-manual-resync` ケースとして追加し、Stage Preview をターゲットに tone=server バナー → manual resync → `audit.logReplayGapState` 出力の流れを検証。実行ログは `artifacts/e2e/20251129T105517Z/playwright-realtime-gap.log` に保管し、本ログと `docs/web-client/ux/legacy/CHART_UI_GUIDE_INDEX.md` の Playwright 追加節を同期。
