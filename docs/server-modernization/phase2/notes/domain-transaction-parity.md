# ドメイン JPQL トランザクション網羅表（2026-06-16）

## 1. 対象ケース
- **Case ID**: `user_profile`（Checklist #48 相当）
- **API**: `GET /user/doctor1`
- **ヘッダープロファイル**: `tmp/trace/user_profile.headers`（`X-Trace-Id: trace-user-profile-manual` を付与）
- **証跡**:
  - HTTP レスポンス: `artifacts/parity-manual/user_profile_trace/{legacy,modern}/response.json`
  - SQL ログ: `artifacts/parity-manual/JPQL/legacy.log`, `artifacts/parity-manual/JPQL/modernized.log`
  - 差分: `artifacts/parity-manual/JPQL/jpql.diff`

| レイヤー | Legacy JPQL/SQL | Modernized JPQL/SQL | 備考 |
| --- | --- | --- | --- |
| UserServiceBean#getUser | `select ... from d_users usermodel0_ where usermodel0_.userId=?` | `select ... from d_users um1_0 where um1_0.userId=?` | 両サーバーとも同一の WHERE 句。モダナイズ側は短い別名 (`um1_0`) を使用。 |
| FacilityModel リレーション | `select ... from d_facility ... where id=?` | 同左 | 施設情報の遅延ロードが両環境とも eager のため追加クエリが発生。 |
| RoleModel リレーション | `select ... from d_roles ... where c_user=?` | 同左 | 監査用途のロール参照。モダナイズ側は `roles` → `r1_0` へ alias が変わるのみ。 |

### 観測結果
- JPQL → SQL 変換結果は alias 文字列以外に差異なし。`hibernate.show_sql` を双方で有効化したことで `scripts/jpql_trace_compare.sh` による差分確認が可能になった。
- Legacy 側の `LogFilter` には traceId の埋め込みが無く、HTTP ログと SQL ログの突合には `X-Trace-Id` ヘッダーを別途控えておく必要がある。モダナイズ側は `traceId=<value>` が自動ログ出力される。
- 2025-11-12: Legacy WAR リネーム処理の `ls "server/target"/*.war` が文字列扱いになっていた問題を `patches/legacy_war_rename_fix.diff` で修正し、`artifacts/parity-manual/build/legacy_war_missing/start_legacy_modernized_fix.log` に `+ WAR_DIR=server/target` → `+ FIRST_WAR=server/target/opendolphin-server-2.7.1.war` → `+ mv ...` の実行証跡を採取済み。Dockerfile / `scripts/start_legacy_modernized.sh` の両方で同じ quoting を採用したため、人手検証と CI ビルド結果が乖離しない。

### 残課題 / 次アクション
1. Checklist #49〜#50, #73〜#74 に対応する `KarteServiceBean`, `PatientServiceBean`, `PVTServiceBean` 等の JPQL を同手順で採取する。少なくとも `/chart/WEB1001/summary`, `/chart-events`, `/pvt/*` 系を追加で叩くため、サンプルデータ投入が必要。
2. `scripts/jpql_trace_compare.sh` の結果を CI からも実行できるよう、対象ケース一覧（JSON or CSV）を整備する。
3. 現状のログは ANSI エスケープ文字を含むため、将来的には `docker logs` から取得する際に `ansi2txt` 等で除去するラッパーを追加する。
4. Audit/JMS 強化 TODO（`TRACEID_JMS_RUNBOOK.md §5` 最新節より）
   - **LogFilter null-safe 化**: `server/src/main/java/open/dolphin/rest/LogFilter.java` の `password.equals("md5")` / `remoteUser.split("@")` などが未認証アクセスで NPE になる。Legacy 側でも TraceId を保持できるよう `StringUtils.equals()` 相当の null ガードと `X-Trace-Id` の MDC 連携を追加する。検証は `ops/tools/send_parallel_request.sh --profile compose GET /dolphin/activity/2025,04`（`trace_http_400`）および `rest_error_bad_request` シナリオで実施し、`artifacts/parity-manual/TRACEID_JMS/20251110T133000Z/trace_http_400/` を上書き更新する。
   - **TouchRequestContext fallback**: `server-modernized/src/main/java/open/dolphin/touch/support/TouchRequestContextExtractor.java` と `TouchRequestContext` に facility 未指定時のフォールバック（`remoteUser` が `doctor1` のみでも `facilityId` 列を復元）を追加し、コメントで fallback ロジックと `X-Trace-Id` 採番位置を明記する。`rest_error_unauthorized`（`trace_http_401`）を `ops/tests/api-smoke-test/headers/trace-session.headers` から `password` 行を削除したヘッダーで再走し、`artifacts/parity-manual/TRACEID_JMS/20251110T221659Z/trace_http_401/` の 500 → 401 化と JMS 発火を確認する。
   - **`d_audit_event_id_seq` 再採番手順**: `ops/db/local-baseline/reset_d_audit_event_seq.sql`（新規）で `\copy d_audit_event to '/tmp/d_audit_event_before_seq_reset.csv' csv header` → `select coalesce(max(id),0)+1` → `setval('d_audit_event_id_seq', next_id, true)` → `insert into d_audit_event (...) values (default,'SEQ_SMOKE',...) returning id` を一括実行できるようにする。結果は `artifacts/parity-manual/db/20251111T062323Z/karte_id_check.txt` と同じディレクトリに `d_audit_event_seq_validation.txt` を追加し、`rest_error_internal`（`trace_http_500`）の再実行で Audit/JMS が連番になることを確認する。 **2025-11-11 更新:** スクリプト側で `:audit_event_status_log` への `min/max/count/next_id` 出力と `LOCK TABLE d_audit_event IN EXCLUSIVE MODE` を自動化済みなので、Runbook §5.3(2)(3) の採取ログはコマンド 1 本で揃う。
   - **テスト / 証跡更新**: 上記 3 件を反映後、`ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` の `rest_error_*` ケースで `expected_status` を最新化し、`artifacts/parity-manual/TRACEID_JMS/<new RUN_ID>/` と `artifacts/parity-manual/db/<new RUN_ID>/` に HTTP/JMS/SQL/`logs/jms_dolphinQueue_read-resource.txt` を保存する。`TRACE_PROPAGATION_CHECK.md` と `PHASE2_PROGRESS.md` の TODO にも同じ差分候補を転記しておく。

## 共通モジュール運用方針（2025-11-12 更新）

### 背景
- `opendolphin-common` は Legacy サーバー（Java EE 7/WildFly 10）、Modernized サーバー（Jakarta EE 8/WildFly 26）、Swing クライアントの 3 系統が同一 jar を参照する前提で構成されている。
- Parity 証跡（本ドキュメントおよび `scripts/jpql_trace_compare.sh`）では DTO/JPA メタデータに差異があると比較が破綻するため、共通モジュールを複製しないこと自体が JPQL/SQL 同一性検証の前提条件になる。
- `common/pom.xml` の `jakarta-no-persistence` 実行 ID は `opendolphin-common-<version>-jakarta.jar` を併産し、Modernized 側は legacy と同じクラス構成を維持したまま Jakarta 名前空間へ差し替えられる。

### 方針
1. **単一ソース／単一バイナリ維持**: `common/src/main/java` の InfoModel・Converter を 1 つの Git 管理単位として保持し、Legacy/Modernized/Swing/Web のいずれも「同じ JAR を再配布する」ルールを明示的に維持する。
2. **分類子付き配布を標準化**: Modernized サーバーは `-jakarta` classifier 付き JAR を `server-modernized/pom.xml` から取得し、Legacy + Swing は classifier なしを利用する。両者の差分は `persistence.xml` の有無に限定し、DTO/エンティティ/値オブジェクトのコードは完全一致させる。
3. **参照窓口の一本化**: Web クライアント／モダナイズ双方の開発者説明は本節と `docs/web-client/architecture/REPOSITORY_OVERVIEW.md`（Modules セクション）に集約し、質疑はこれらを一次回答とする。

### 期待効果と運用メリット
- **DTO パリティ保証**: Swing/Web/REST すべてが `open.dolphin.infomodel.*` を同バージョンでシリアライズするため、DTO 差分による 500 やシリアライズ失敗を防ぎ、`PatientModel`/`DocumentModel` のフィールド追加が同時に展開される。
- **JPQL/SQL 比較の省力化**: Legacy/Modernized の JPA メタモデルが揃うことで、JPQL→SQL の差分が alias やヒントに限定され、本ドキュメントの観測結果を根拠に説明しやすくなる。
- **jar 管理コスト削減**: `ext_lib/` への複製や Maven 座標変更なしに `opendolphin-common-2.7.1.jar` と `-jakarta` を Artifactory/ローカルリポジトリへ配布できる。

## 2. Trace Harness（Checklist #49/#73/#74）

| Checklist | API | Session Bean | Trace Case | 状態 | 備考 |
| --- | --- | --- | --- | --- | --- |
| #49 | `GET /dolphin/activity/{year,month,count}` | `SystemServiceBean` (`@SessionOperation`) | `trace_http_400` | ⚠️ Legacy=400 / Modern=500 | RUN_ID=`20251111TtracefixZ`: `logs/send_parallel_request.log` で Legacy=400→Modern=500 を再現。Modernized は `artifacts/parity-manual/TRACEID_JMS/20251111TtracefixZ/trace_http_400/modern/headers.txt` が `HTTP/1.1 500` (`jakarta.transaction.RollbackException ... Could not commit transaction`) を返し、`response.json` も同メッセージ。`SystemResource#getActivities`（`server-modernized/src/main/java/open/dolphin/rest/SystemResource.java:117-188`）が不正パラメータでも `recordAudit(...)` → `BadRequestException` を即時送出するため、`AuditTrailService` の CMT トランザクションが `rollbackOnly` となり 500 応答へ昇格している。パラメータ検証〜400 応答を Audit とは別トランザクションに切り離し、`Response.status(BAD_REQUEST)` を明示的に返すガードが必要。 |

> **2025-11-11 修正内容（次 RUN_ID=`20251111TclaimfixZ` で検証）**  
> ・`SystemResource#getActivities` が `param` 解析を `parseActivityRequest()` へ切り出し、入力エラー時は監査を実行せずに `BadRequestException` を返す（`recordAudit` 実行箇所は正常完了後のみ）。  
> ・同 helper では WARN ログを追加して `rawParam` と失敗理由を記録。  
> ・再取得手順: `PARITY_HEADER_FILE=tmp/trace_http_400.headers TRACE_RUN_ID=20251111TclaimfixZ ops/tools/send_parallel_request.sh --profile compose trace_http_400` を実行し、`artifacts/parity-manual/TRACEID_JMS/20251111TclaimfixZ/trace_http_400/modern/headers.txt` が 400 へ戻ることと `logs/modern_trace_http.log` の `trace-http-400-20251111TclaimfixZ` 行を確認する。
| #73 | `GET /touch/user/{userId,facilityId,password}` | `TouchUserServiceBean` (`IPhoneServiceBean` 経由) | `trace_http_401` | ⚠️ Legacy=401 / Modern=403 | RUN_ID=`20251111TtracefixZ`: Legacy は `trace_http_401/legacy/headers.txt` どおり 401 + `WWW-Authenticate` を返却。Modernized は `trace_http_401/modern/headers.txt` が 403 となり、`logs/modern_trace_http.log` に `Unauthorized user: 1.3.6.1.4.1.9414.72.103:doctor1 ... traceId=trace-http-401-20251111TtracefixZ` が 2 行出力されるだけで JMS/Audit 無し。`LogFilter` が password 欠落を Forbidden 扱いしてしまい `TouchRequestContextExtractor` / `TouchAuthHandler` の facility フォールバックまで届かないため、`TouchRequestContextExtractor`（`server-modernized/src/main/java/open/dolphin/touch/support/TouchRequestContextExtractor.java`）に facility + userId から composite principal を再構成する分岐と `TouchAuthHandler`（`server-modernized/src/main/java/open/dolphin/touch/TouchAuthHandler.java`）で欠落認証を `NotAuthorizedException`（401）へマッピングする補強が必要。 |

> **2025-11-11 修正内容（次 RUN_ID=`20251111TclaimfixZ` で検証）**  
> ・`server-modernized/rest/LogFilter.java` で `sendUnauthorized()` を追加し、ヘッダー認証失敗時は 401 + `WWW-Authenticate: Basic realm="OpenDolphin"` を返すよう統一。  
> ・`TouchRequestContextExtractor` が `/touch/user/{user,facility,password}` のパスセグメントから facility/user を補完し、`X-Facility-Id` 欠落時でも composite principal を生成。  
> ・`TouchAuthHandler` は `resolveRemoteFacility()` が null の場合に 401 を送出し、`WWW-Authenticate` を必ず付与。  
> ・再取得手順: `PARITY_HEADER_FILE=tmp/trace_http_401.headers TRACE_RUN_ID=20251111TclaimfixZ ops/tools/send_parallel_request.sh --profile compose trace_http_401` を再実行し、`artifacts/parity-manual/TRACEID_JMS/20251111TclaimfixZ/trace_http_401/modern/headers.txt` が 401 となり JSON ボディに `traceId` が含まれることを確認。`logs/modern_trace_http.log` へ 401 WARN が 1 件のみ残ることを証跡化する。
| #74 | `GET /karte/pid/{patientPk,date}` | `KarteServiceBean` | `trace_http_500` | ⚠️ Legacy=500 / Modern=500 (payload 差異) | RUN_ID=`20251111TtracefixZ`: 双方 500 だが Legacy `response.json` は `Karte result is empty`、Modernized は `Karte result is empty: pid lookup` かつ JMS/Audit は無記録。`KarteResource#toConverter`（`server-modernized/src/main/java/open/dolphin/rest/KarteResource.java:720-750`）が `null` を `internalError` へ変換する際に `KarteBeanConverter`（`common/src/main/java/open/dolphin/converter/KarteBeanConverter.java`）へコンテキスト不在のまま渡し、SessionOperation/Audit で traceId が拾えない。Legacy 同等の 500 を維持しつつ `KarteBeanConverter` 側で空結果時の patientId/traceId を記録して `AuditTrailService` 呼び出しを継続させ、`TRACE_PROPAGATION_CHECK.md` で JMS/SO を採取できるよう補強する。 |

### 2.1 RUN_ID=20251111TtracefixZ Modernized 設計メモ（trace_http 400/401/500）
- **`SystemResource#getActivities`（`server-modernized/src/main/java/open/dolphin/rest/SystemResource.java:117-188`）**: `trace_http_400/modern/response.json` が `jakarta.transaction.RollbackException` になるのは、ヘッダー検証前に `recordAudit("SYSTEM_ACTIVITY_SUMMARY", ...)` を実行し同一トランザクションで `BadRequestException` を送出しているため。`TraceId=trace-http-400-20251111TtracefixZ` で `AuditTrailService` が `rollbackOnly` になり HTTP 500 へ昇格している。対策: (1) `param` 分解と `BadRequestException` 変換を JTA 非参加（`@Transactional(TxType.NEVER)` or `Response.status(BAD_REQUEST)`）のブロックに分離、(2) 失敗監査は `try/catch` 内で `auditTrailService.record` を `REQUIRES_NEW` 相当で実行し、例外は 400 へ丸める。完了後 `ops/tools/send_parallel_request.sh --profile compose trace_http_400` を再走し、`artifacts/.../<next-run>/trace_http_400/modern/` に 400 ステータスを採取する。
- **`TouchRequestContextExtractor` ＋ `TouchAuthHandler`（`server-modernized/src/main/java/open/dolphin/touch/support/TouchRequestContextExtractor.java`, `.../touch/TouchAuthHandler.java`）**: `trace_http_401` では `password` ヘッダーを削除したため `LogFilter` が `Unauthorized user ... traceId=trace-http-401-20251111TtracefixZ` を WARN → 403 応答。`TouchRequestContextExtractor` が facility/header から principal を再構築し `TouchAuthHandler` が `NotAuthorizedException` (401) を返す設計に切り替えれば、ヘッダーベース認証を無効化しても `TouchUserServiceBean` まで進み、`WWW-Authenticate` を維持した 401 を返せる。具体的には (1) facility ヘッダー or Path param から `remoteUser` を強制生成、(2) facility mismatch は 403、資格情報欠落は 401 を選択、(3) `TouchErrorMapper` 経由で JSON ボディと traceId を返す。再検証は `ops/tools/send_parallel_request.sh --profile compose trace_http_401` + `tmp/trace_http_401.headers`（password 行削除）で行い、`logs/modern_trace_http.log` に 401 WARN/INFO を残す。
- **`KarteBeanConverter` / `KarteResource#toConverter`（`common/src/main/java/open/dolphin/converter/KarteBeanConverter.java`, `server-modernized/src/main/java/open/dolphin/rest/KarteResource.java:720-750`）**: 無効 PID で `KarteServiceBean` が `null` を返すと `internalError` → 500 となり、Legacy と HTTP ステータスは一致するが `d_audit_event_latest.tsv` / `jms_dolphinQueue_read-resource.txt` が空のまま。`trace_http_500/modern/response.json` のとおり `"pid lookup"` で打ち切られているため、(1) `KarteBeanConverter` に `Optional<KarteBean>` 受け入れ + patientId, traceId を `AuditEventPayload` details へ出力する null-safe ガード、(2) `KarteResource` で `TouchAuthHandler` 同様に `TraceId` をログへ転写し JMS/Audit を必ず発火させるフックを追加する。修正後は `ops/tools/send_parallel_request.sh --profile compose trace_http_500` を再実行し、`artifacts/.../trace_http_500/modern/headers.txt` が `Karte result is empty` のままでも Audit/JMS に `trace-http-500-<next-run>` を記録させる。 
| Baseline | `GET /serverinfo/jamri` | なし（REST フィルタのみ） | `trace_http_200` | ✅ `artifacts/parity-manual/TRACEID_JMS/20251110T133000Z/trace_http_200/` に更新（DocumentModel persistence 追加 + `d_audit_event` 抜粋）。Legacy は traceId を出力しないまま、Modernized は `traceId=trace-http-200` を INFO に記録。 |

- **2025-11-11 対応メモ**: Legacy 側は `server/src/main/java/open/dolphin/rest/LogFilter.java` に facility ヘッダー由来の principal 合成フォールバックを追加し、`TouchUserServiceBean`（実装は `IPhoneServiceBean`）へ制御が渡る前に 401 + `WWW-Authenticate` を確実に返すよう整理した。Modernized 側は `TouchRequestContextExtractor`/`TouchAuthHandler` で facility fallback と trace ログ、安全な `KarteResource` + `KarteBeanConverter` で null 発生時に 500 を送出する防御を実装済み。Docker/WildFly を再ビルドしたら `ops/tools/send_parallel_request.sh --profile compose trace_http_{401,500}` を再実行し、`artifacts/parity-manual/TRACEID_JMS/<next-run>/trace_http_{401,500}/` に HTTP/JMS/Audit を保存して parity を再確認すること。検証ログは `TRACE_PROPAGATION_CHECK.md` と `PHASE2_PROGRESS.md` に追記し、`rest_error_{unauthorized,internal}` の期待ステータスを 401/500 へ更新する。 

- 400/401/500 ケースは `ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` に期待ステータスと操作ノートを追加し、CLI で再現できるようにした。  
- Trace ID は `test_config.manual.csv` の `trace-id` 列に記載しており、`trace-session.headers` を複製して `X-Trace-Id` を上書きする運用とした。  
- Legacy サーバーは `ops/legacy-server/docker/configure-wildfly.cli` が `org.wildfly.extension.micrometer` を要求するためビルド不可。`artifacts/parity-manual/TRACEID_JMS/20251108T0526Z/legacy_build.log` に詳細を残した上で、Modernized 側のみ CLI 検証を進める。

### 2.1 2025-11-10 07:06Z 追記（RUN_ID=20251110T070638Z）
- `trace_http_{200,400,401,500}`, `trace-schedule-jpql`, `trace-appo-jpql` を再取得しようとしたが、`ops/tools/send_parallel_request.sh --profile compose` がすべて `curl: (7) Failed to connect to localhost port {8080,9080}` で停止し HTTP ログは取得できなかった。
- 証跡: `artifacts/parity-manual/TRACEID_JMS/20251110T070638Z/README.md`（実行手順と失敗サマリ）、`logs/send_parallel_request.log`（各ケースの `status=000 / exit=7`）を参照。
- `docker ps` が `The command 'docker' could not be found in this WSL 2 distro.` を返し、Legacy/Modernized コンテナが不在。これにより `trace_http_401` の Touch 経路や `trace-appo-jpql` の SessionOperation ERROR を再現できていない。
- 次アクション: Docker Desktop ↔ WSL 統合を有効化した環境へ切り替えてコンテナを起動した後、本 RUN_ID と同じヘッダー／payload で再実行し、§2 の表を更新する。Touch 系 API では `open.dolphin.touch.session.{EHTServiceBean,IPhoneServiceBean}` にも `@SessionOperation` を付与する改修チケットが必要（詳細は `TRACE_PROPAGATION_CHECK.md` §7.2）。

### 2.2 2025-11-10 追記: DocumentModel/persistence + Trace Harness RUN_ID=20251110T133000Z
- DocumentModel の関連エンティティ (`ModuleModel`, `SchemaModel`, `AttachmentModel`) を `server-modernized/src/main/resources/META-INF/persistence.xml` に列挙し、`server-modernized/tools/flyway/sql/V0224__document_module_tables.sql` で Modernized DB に `d_document`/`d_module`/`d_image`/`d_attachment` を投入した。DocumentModel が参照していたテーブルが存在しないことで発生していた `UnknownEntityException` を回避するための基盤が整った。
- RUN_ID=`20251110T133000Z` は次に割り当てる trace harness で、`tmp/trace_http_200.headers` を使って `trace_http_200` を再取得し、HTTP/trace/JMS/`d_audit_event` を `artifacts/parity-manual/TRACEID_JMS/20251110T133000Z/trace_http_200/` に記録する予定。`trace_http_{400,500}` は AuditTrail ID 衝突バグで Modernized が 500 を返す既存 issue として README に記載しており、同様の結果を想定している。
- Modernized AuditTrailService が `eventHash` 想定の軽量クエリへ移行済みな点を踏まえ、RUN_ID=`20251110T133000Z` では `d_audit_event_id_seq` の再採番変動を追跡できるよう `artifacts/parity-manual/TRACEID_JMS/20251110T133000Z/d_audit_event.log` を収集予定。現状では `d_audit_event` に TraceId が残らず `SYSTEM_ACTIVITY` のみとなっているため、DocumentModel/persistence + JMS/Audit の連携強化をブロッカーとして継続している。
- 次アクション: Modern WildFly を再ビルドし `docker compose -f docker-compose.modernized.dev.yml up -d db-modernized server-modernized-dev` を起動したうえで `GET /schedule/pvt/2025-11-09` を trace ヘッダー付きで実行し、HTTP 200 および `d_audit_event`/JMS TraceId を確認する。検証結果は `artifacts/parity-manual/TRACEID_JMS/20251110T133000Z/trace_http_200/` に保管し、`LEGACY_MODERNIZED_CAPTURE_RUNBOOK.md`／`PHASE2_PROGRESS.md`／`docs/web-client/planning/phase2/DOC_STATUS.md` に RUN_ID・ブロッカー・次アクションとして整理したうえで次 RUN を採番する。

## 3. 2025-11-09〜10: Karte / Patient / Appo / Schedule

| Service / Endpoint | Legacy TX境界 | Modernized TX境界 | JPQL差分メモ | リスク / 対応方針 | 参照証跡 |
| --- | --- | --- | --- | --- | --- |
| `PatientServiceBean#getPatientById` (`GET /patient/id/0000001`) | `@Stateless`（CMT、`@SessionOperation` なし） | `@ApplicationScoped @Transactional @SessionOperation` | Legacy/Modern とも `from PatientModel p where p.facilityId=? and p.patientId like ?`。Modern 側のみ `ESCAPE ''`。 | Legacy=200（DTO/保険を返却）、Modern=500（`SessionServiceException` → `NoResultException`）。`remoteUser=anonymous` が解決できず facilityId が未確定のまま。 | `artifacts/parity-manual/JPQL/20251110T122417Z/PatientServiceBean/`（TraceId=`jpql-patient-20251110T122417Z`。`d_audit_event` は空）。 |
| `KarteServiceBean#getKarte(fid,pid,fromDate)` (`GET /karte/pid/0000001,2024-01-01`) | `@Stateless` | `@ApplicationScoped @Transactional @SessionOperation` | JPQL は `d_patient` 参照のみで 0 件。Legacy は `{}` を返し、Modern は `KarteBeanConverter` が `null` を扱えず 400。 | `WEB1001` seed 投入後も Modern は `Not able to deserialize data provided`。`KarteBeanConverter` の null-safe 化 + `chart_summary` リトライが必要。 | `artifacts/parity-manual/JPQL/20251110T122417Z/KarteServiceBean/`（TraceId=`jpql-karte-20251110T122417Z`）。 |
| `ScheduleServiceBean#getPvt` (`GET /schedule/pvt/2025-11-09`) | `@Stateless` | `@ApplicationScoped @Transactional @SessionOperation` | Legacy: 5 クエリ（`d_patient_visit`→`d_patient`→`d_health_insurance`→`d_karte`→`d_document`）。Modern: `d_patient_visit` 単独（`like ? escape ''`）。 | HTTP は両環境 200。ただし Modern は `{"list":null}`。`remoteUser=anonymous` のまま DTO 変換が abort するため facility 認証を修正する。監査テーブルは TraceId を記録していない。 | `artifacts/parity-manual/JPQL/20251110T122417Z/ScheduleServiceBean/`（TraceId=`jpql-schedule-20251110T122417Z`）。 |
| `AppoServiceBean#putAppointments` (`PUT /appo`) | `@Stateless` | `@ApplicationScoped @Transactional @SessionOperation` | Legacy/Modern とも `SELECT d_appo ...` → `DELETE d_appo`。今回の `jpql.diff` は alias 差分のみ。 | シード（`id=8001`）を再投入すれば Legacy/Modern とも 200 (`response=1`)。`remoteUser=anonymous` と監査未記録は継続。 | `artifacts/parity-manual/JPQL/20251110T122417Z/AppoServiceBean/`（TraceId=`jpql-appo-20251110T122417Z`、README に reseed/CLI 条件を追記）。 |

- RUN_ID=`20251110T122417Z` で 4 サービスの HTTP/JPQL/ログを採取し、`README.md` に CLI 条件・`docker compose exec db-{legacy,modern}` を使った監査取得手順・reseeding の前提を記載した。`d_audit_event` は Legacy=空、Modern=SYSTEM_ACTIVITY のみ（TraceId 未記録）であることを log として残している。
- `ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` の `rest_error_schedule_unknown_entity` / `rest_error_appo_missing_entity` / `rest_error_chart_summary_seed_gap` は最新 RUN_ID に揃えた。Schedule/Appo は `expected_status=200` を維持しつつ、`TODO(remoteUser=anonymous)` と `TODO(WEB1001 seed gap)` に観測結果と再取得条件を追記した。

- **Claim/JMS 差分（RUN_ID=`20251111TclaimfixZ3`）**: Claim ルートは 2025-11-12 時点で Legacy 側へ `/20/adm/eht/sendClaim` を移植し、Modernized と同じ JMS/Audit 経路を確立済み。両環境とも `ops/db/local-baseline/reset_d_audit_event_seq_batch.sql`（正式パスは `ops/db/local-baseline/`）でシーケンスを再採番してから比較し、`scripts/diff_d_audit_event_claim.sh 20251111TclaimfixZ3 20251111TclaimfixZ2` の出力と `artifacts/parity-manual/TRACEID_JMS/20251111TclaimfixZ3/README.md` に TraceId 差分をまとめる。Legacy/Modern の差分は `EHT_CLAIM_SEND` に限定され、`messages-added` の増分が 4L→5L で揃ったことを確認した。

### 3.1 2025-11-10: 取得リトライ状況
- `RUN_ID=20251110T122417Z (macOS Docker Desktop)`: Patient/Karte/Schedule/Appo を再取得。Legacy/Modern それぞれの HTTP/JPQL/`docker compose logs` を `artifacts/parity-manual/JPQL/20251110T122417Z/<Service>/` に保存し、Appo については実行毎に `/tmp/reseed_appo.sql` を流し込んで `id=8001` を復元した。`d_audit_event` は Legacy=空、Modern=SYSTEM_ACTIVITY のみで TraceId が記録されないことをログ化済み。監査テーブル改善が完了するまでは `d_audit_event_{legacy,modern}.log` が空でも本 RUN_ID を正とする。
- `RUN_ID=20251110T034844Z`: `ops/tools/send_parallel_request.sh --profile compose` を Patient/Karte/Schedule/Appo 4 ケースで再実行したが、ホストに Docker Desktop/compose が無く `curl: (7) Failed to connect to localhost port {8080,9080}` で失敗。詳細は `artifacts/parity-manual/JPQL/20251110T034844Z/README.md` と `*_request.log` を参照。HTTP リクエスト痕跡のみ生成できたため、`legacy.raw.log`／`modern.raw.log`、`d_audit_event` は未更新。

### 3.2 TX/JPQL/Persistence 差分メモ
- `server-modernized/src/main/resources/META-INF/persistence.xml` に `open.dolphin.infomodel.PatientVisitModel` / `AppointmentModel` / `AuditEvent` を列挙済みであり、Legacy と同じエンティティが JPA 管理対象になっていることを確認した。
- `ops/db/local-baseline/local_synthetic_seed.sql` で `appointment_model` / `patient_visit_model` テーブルとシードを定義しているため、`opendolphin_modern` へ流し込めば `trace-appo-jpql` / `trace-schedule-jpql` の ID（例: `id=8001`, `F001` facility）を復元できる。Flyway V0223 に続けて同スクリプトを再投入する。
- `d_audit_event` 抜粋は `trace_id` 列追加（`V0227__audit_event_trace_id.sql`）後に実施する。compose 環境では `docker exec opendolphin-postgres{-modernized} psql ... -c "ALTER TABLE d_audit_event ADD COLUMN IF NOT EXISTS trace_id VARCHAR(64);"` を流し、`SELECT event_time,action,trace_id,request_id FROM d_audit_event WHERE trace_id='trace-http-400-<RUN_ID>'` を `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/d_audit_event_trace_http_*.sql`（Legacy は `_legacy` サフィックス）へ保存する。完了したら `SERVER_MODERNIZED_DEBUG_CHECKLIST.md` #65 を更新する。
- `ScheduleResource` / `AppoResource` は `HttpServletRequest#getRemoteUser()` に依存するが、Modernized 側では WildFly Elytron が匿名レスポンスを返しており `remoteUser=anonymous` のまま。`TraceFilter` or `LogFilter` で `trace-session.headers` の `Authorization` を JACC Principal に伝播させる修正を GitHub Issue #ScheduleRemoteUser でトラッキングする。
- `ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` をシナリオ管理の単一ソースとし、Trace Harness（§2）と本表（§3）の差分が発生した場合は同 CSV を起点に Runbook を更新する。
- **UDPATE（RUN_ID=`20251110TnewZ`）**: `rest_error_letter_fk` / `rest_error_lab_empty` / `rest_error_stamp_data_exception` 向けに `tmp/parity-headers/<case>_<RUN_ID>.headers`（MD5 password=`632080fabdb968f9ac4f31fb55104648`, `X-Trace-Id: parity-<case>-<RUN_ID>`, PUT 系は `Content-Type: application/json`）と `tmp/parity-letter/*.json` をテンプレ化し、README.manual.md にヘッダー・証跡配置・期待レスポンスを追記済み。次回 RUN では `<new RUN_ID>` を付与したヘッダーファイルを複製し `PARITY_OUTPUT_DIR=artifacts/parity-manual/<case>/<new RUN_ID>` へ保存するだけで `ops/tools/send_parallel_request.sh` を再実行できる。
- **UDPATE（RUN_ID=`20251111T070532Z`）**: Compose 環境を `scripts/start_legacy_modernized.sh start` で起動後、`docker run --rm --network legacy-vs-modern_default -v "$PWD":/workspace buildpack-deps:curl bash -lc "cd /workspace && BASE_URL_LEGACY=http://server:8080/openDolphin/resources BASE_URL_MODERN=http://server-modernized-dev:8080/openDolphin/resources PARITY_HEADER_FILE=tmp/parity-headers/<case>_${RUN_ID}.headers ... ops/tools/send_parallel_request.sh --profile compose <METHOD> <PATH> <request_id>"` 相当の手順で `appo,schedule,letter,lab,stamp` を再取得。`artifacts/parity-manual/{appo|schedule|letter|lab|stamp}/20251111T070532Z/` に HTTP/headers/meta と `logs/{legacy,modern}_trace.log`／`modern_trace_context.log`（エラーケースのみ）／`d_audit_event_{legacy,modern}.txt`／`jms_note.txt` を保存した。Appo は Legacy/Modern=200（レスポンス=1）、Schedule も Legacy/Modern=200 かつ `list` に `架空 花子` 1 件が復活した一方、Letter=200/500（`fk_d_letter_module_karte` → `ARJUNA016053`）、Lab=両環境 `{"list":null}`、Stamp=500/500（Legacy `First Commit Win Exception`, Modern `Bad value for type long … treeBytes`）で差分継続。全ケースで `docker compose exec db* psql` による `d_audit_event` 抜粋は `SYSTEM_ACTIVITY_SUMMARY` のみ、`logs/jms_note.txt` も JMS ヒット無しである旨を記録し、`ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` / `tmp/parity-headers/<case>_${RUN_ID}.headers` を同 RUN_ID へ更新した。
- **UPDATE（RUN_ID=`20251111TclaimfixZ` Audit/JMS 再取得）**: rest_error は引き続き `artifacts/parity-manual/{letter,lab,stamp}/20251111TrestfixZ/` を参照しつつ、Claim/JMS は新たに `TRACEID_JMS/20251111TclaimfixZ/claim_send/http/{legacy,modern}/` と `logs/send_parallel_request.log`（401/401 + `WWW-Authenticate`）を採取。`ops/db/local-baseline/reset_d_audit_event_seq_batch.sql` を `docker exec opendolphin-postgres{,-modernized}` で流し、`artifacts/parity-manual/db/20251111TclaimfixZ/{legacy,modern}/audit_event_{backup.csv,status_log.txt,validation_log.txt}` を取得したが `logs/jms_dolphinQueue_read-resource.{before,}.txt` は `messages-added=0L` のまま、`logs/d_audit_event_claim.tsv` も 2025-11-10 の `EHT_CLAIM_SEND` 1 行のみで更新されず。Basic 認証／ORCA 資格情報を見直し、messages-added>0L を記録する RUN を次タスクとして継続する。
- **UPDATE（RUN_ID=`20251111TclaimfixZ2` Claim/JMS 再検証）**: ヘッダーを `userName=1.3.6.1.4.1.9414.72.103:doctor1`・MD5 パスワード・Basic 認証付きに刷新し、`ops/db/local-baseline/reset_d_audit_event_seq_batch.sql` で取得した `artifacts/parity-manual/db/20251111TclaimfixZ2/{legacy,modern}/audit_event_{backup.csv,status_log.txt,validation_log.txt}` を追加。`docker run --network legacy-vs-modern_default ... send_parallel_request.sh --profile compose PUT /20/adm/eht/sendClaim claim_send` を実行したところ、Legacy はエンドポイント未実装で `HTTP/1.1 404`、Modern は `AuditTrailService#record` が `d_audit_event_pkey (id=59)` と衝突し `HTTP/1.1 500`。ただし JMS は `logs/jms_dolphinQueue_read-resource.{before,after}.txt` で `messages-added=2L→3L` と増分が確認でき、Trace→JMS までの経路は復旧。`logs/d_audit_event_claim.tsv` に新規 `EHT_CLAIM_SEND` が出力されないことと `artifacts/parity-manual/TRACEID_JMS/20251111TclaimfixZ2/claim_send/claim_send/{legacy,modern}/`（404/500 ヘッダー + 500 応答本文）を明示し、Legacy 実装補填と Audit PK 衝突解消を継続課題とした。
- **UPDATE（RUN_ID=`20251111TclaimfixZ3` Claim/JMS 本番フロー）**: Legacy 側 `/20/adm/eht/sendClaim` を `server/src/main/java/open/dolphin/adm20/rest/EHTResource.java` へ移植し、`IDocInfo` の保険モデル null ガードと `ClaimSender` の `Logger` 初期化 null-safe 化で 500 を解消。`ops/db/local-baseline/reset_d_audit_event_seq_batch.sql` を `docker exec opendolphin-postgres{,-modernized}` から実行し、`artifacts/parity-manual/db/20251111TclaimfixZ3/{legacy,modern}/audit_event_{backup.csv,status_log.txt,validation_log.txt}` を更新。helper コンテナから `PARITY_HEADER_FILE=tmp/claim-tests/claim_20251111TclaimfixZ3.headers`・`PARITY_BODY_FILE=tmp/claim-tests/send_claim_success_20251111TclaimfixZ3.json` を指定して `ops/tools/send_parallel_request.sh --profile compose PUT /20/adm/eht/sendClaim claim_send` を再送した結果、Legacy/Modern とも `HTTP/1.1 200`（`TRACEID_JMS/20251111TclaimfixZ3/claim_send/claim_send/{legacy,modern}/`）となり、`jms_dolphinQueue_read-resource.{before,after}.txt` では `messages-added=4L→5L`・`message-count=0L` を記録。`logs/d_audit_event_claim.tsv` には `id=80/79/78` の `EHT_CLAIM_SEND` が追記され、Modern 側の `request_id` は UUID（`f0cc8ab4-...` 等）で保存された。関連ログは `TRACEID_JMS/20251111TclaimfixZ3/logs/{send_parallel_request.log,d_audit_event_claim.tsv,jms_dolphinQueue_read-resource.*}` を参照。

- **FOLLOW-UP（RUN_ID=`20251111TclaimfixZ` 再取得計画）**: `server-modernized/rest/LogFilter.java` へ facility 合成フォールバックと 401 応答を導入し、`TouchAuthHandler`／`TouchRequestContextExtractor` 補強と合わせて `PUT /20/adm/eht/sendClaim` の認証エラーが 401+`WWW-Authenticate` で揃うようにした。`tmp/claim-tests/claim_20251111TclaimfixZ.headers`（`password` を誤値へ差し替え）と `tmp/claim-tests/send_claim_success.json` を用い、`ops/tools/send_parallel_request.sh --profile modernized-dev claim_send ${TRACE_RUN_ID}` を実行して `artifacts/parity-manual/TRACEID_JMS/20251111TclaimfixZ/claim_send/http/{legacy,modern}/headers.txt` を比較。Modern 側が 401 へ戻り、`logs/jms_dolphinQueue_read-resource.txt` に `message-count` 変化が無いことを証跡化する。
- **UPDATE（2025-11-12 Stamp parity 再取得）**: `LetterServiceBean` / `NLaboModuleListConverter` の再取得（RUN_ID=`20251111TrestfixZ`）に続き、`StampServiceBean` への bytea 改修＋PU 再登録ビルドを helper コンテナ経由で再検証。`ops/db/local-baseline/stamp_tree_oid_cast.sql` を新設し、Legacy/Modern Postgres の `d_stamp_tree.treebytes` へ `bytea_to_oid` 関数＋暗黙キャストを恒久手順として再適用。さらに Modern DB に欠けていた `d_subscribed_tree`（id/treeId/user_id）を作成し、`GET /stamp/tree/{user}` で 500 を返していた `relation "d_subscribed_tree" does not exist` を解消した。RUN_ID=`20251111TstampfixZ3` では Legacy/Modern=200/200 に加えて Legacy 側 `AuditTrailService` も `STAMP_TREE_PUT` を記録し、両方の JMS で `messages-added=4L` を確認できた（証跡: `artifacts/parity-manual/stamp/20251111TstampfixZ3/`）。
- **NEXT ACTIONS（JMS/Audit 強化）**:
  1. `sendClaim` が 401/403 で止まっている原因（Legacy Basic 認証／WildFly セキュリティドメイン）の修正と、成功時に `messages-added>0L` へ変化したログを `TRACEID_JMS` 配下へ追記する。
  2. rest_error 3 ケースの `logs/d_audit_event_{legacy,modern}.txt` / `logs/d_audit_event_{case}.tsv` / `logs/d_audit_event_latest.tsv` / `logs/jms_dolphinQueue_read-resource.txt` は TraceId 行が 0 件であることを明示した。JMS fix 後に再走し、`EHT_CLAIM_SEND` や `STAMP_*` の新行が入ることを確認する。
  3. `docs/server-modernization/phase2/operations/LEGACY_MODERNIZED_CAPTURE_RUNBOOK.md` と `TRACE_PROPAGATION_CHECK.md` へ RUN_ID=`20251111TrestfixZ` のリンクを追加済み。次回 RUN が完了するまで本表の `rest_error` 行は「コード反映済み・証跡取得中（JMS pending）」扱いとする。

### 3.3 Docker 復旧後チェックリスト
- [ ] **Docker Desktop と compose の健全性確認**: `docker info`, `docker compose version`, `docker context ls` がエラーなく実行でき、`docker ps` に `opendolphin-*` コンテナが表示される。macOS では Docker Desktop > Settings > Resources を 6 CPU / 8 GB RAM 以上に設定し、`/Users/<user>/Documents/OpenDolphin_WebClient` を File Sharing に追加する。
- [ ] **`scripts/start_legacy_modernized.sh start --build` 実行**: `PROJECT_NAME=legacy-vs-modern`（既定値）を維持したまま起動し、`docker compose -p legacy-vs-modern ps` が `db`, `db-modernized`, `server`, `server-modernized-dev` すべて `Up` であることを確認。失敗時は `./scripts/start_legacy_modernized.sh logs server-modernized-dev` を採取し `artifacts/parity-manual/logfilter/<UTC>/` へ保存する。
- [ ] **JPQL ケース再取得**: `PARITY_OUTPUT_DIR=artifacts/parity-manual/JPQL/$RUN_ID` を指定し、`ops/tools/send_parallel_request.sh --profile compose` で `PatientServiceBean`, `KarteServiceBean`, `ScheduleServiceBean`, `AppoServiceBean` を順番に実行。`PARITY_HEADER_FILE=tmp/trace/jpql-<service>-$RUN_ID.headers`、必要に応じて `PARITY_BODY_FILE` を渡す。取得後は `scripts/jpql_trace_compare.sh` を実行し `legacy.normalized.sql` / `modern.normalized.sql` / `jpql.diff` を更新する。
- [ ] **Trace Harness 再実行**: `PARITY_OUTPUT_DIR=artifacts/parity-manual/TRACEID_JMS/$RUN_ID` と `PARITY_HEADER_FILE=tmp/trace-headers/trace_*.headers` を組み合わせ、`trace_http_{200,400,401,500}`／`trace-{schedule,appo}-jpql` を全件送信。`ops/tools/send_parallel_request.sh --profile compose --loop 1` を推奨。Appo 用には `PARITY_BODY_FILE=ops/tests/api-smoke-test/payloads/appo_cancel_sample.json` を指定する。
- [ ] **`d_audit_event` 差分取得**: Legacy/Modernized 両 DB で `docker compose -p legacy-vs-modern exec db psql -U opendolphin -d opendolphin_modern -c "select * from d_audit_event order by event_time desc limit 200"` と `... exec db-modernized ...` を実行し、サービス配下に `d_audit_event.{legacy,modern}.log` を保存。Trace Harness 側も同じ RUN_ID 名義で `TRACEID_JMS/<RUN_ID>/d_audit_event/` に複製する。
- [ ] **JMS ヘッダー/ログ採取**: `TRACEID_JMS/<RUN_ID>/<case>/<env>/headers.txt` に `X-Trace-Id` を含むヘッダーを保存し、`logs/{legacy,modern}_trace-*.log` へ WildFly の `traceId=` ログと JMS publish ログをコピーする。`ops/tools/send_parallel_request.sh` 実行時の `send_parallel_request.log` もディレクトリ直下に必ず残す。
- [ ] **`persistence.xml` / seed 確認**: `server-modernized/src/main/resources/META-INF/persistence.xml`（Jakarta 版）に `PatientVisitModel`, `AppointmentModel`, `LetterModule`, `NLabModule`, `StampTreeModel` が列挙されているか `rg '<class>.*(PatientVisitModel|AppointmentModel|Letter|NLab|Stamp)'` で確認し、結果を `artifacts/parity-manual/persistence-check/$RUN_ID/` にメモ。抜けがあれば WAR を再ビルドして再取得する。併せて `ops/db/local-baseline/local_synthetic_seed.sql` を `docker compose exec db-modernized psql ... -f -` で再投入し、`WEB1001` シードを復元する。
- [ ] **成果物整理とドキュメント更新**: 取得物を `artifacts/parity-manual/{JPQL,TRACEID_JMS,appo,schedule,...}/$RUN_ID/` へ格納し、`付録A` の RUN_ID 一覧に追記。更新内容を `docs/server-modernization/phase2/planning/phase2/DOC_STATUS.md` と `PHASE2_PROGRESS.md` へ反映させる。

### 3.4 Appo/Schedule Audit/JMS 実装案（2025-11-12 設計）
**現状整理**
- `AppoServiceBean`（`server-modernized/src/main/java/open/dolphin/session/AppoServiceBean.java:17-84`）と `ScheduleServiceBean`（同:51-415）は `@SessionOperation` でトレースは生成できるものの、サービス内で `AuditTrailService` を呼び出さず HTTP 200 でも `d_audit_event` が空のまま。`SessionOperationInterceptor`（`.../session/framework/SessionOperationInterceptor.java:19-68`）は `SessionTraceManager` に traceId だけを保存していて、リクエスト属性（remoteUser, facilityId, IP）を `SessionTraceContext` へ載せていないため、セッション層からは監査 actor を得られない。
- JMS 側も `MessagingGateway`（`.../msg/gateway/MessagingGateway.java:33-121`）が Claim/Diagnosis しか dispatch しておらず、Appo/Schedule で `messages-added` が +1 になる経路が存在しない。`TRACEID_JMS_RUNBOOK.md §5.5` の Appo 行にある「Audit が 1 行、JMS が +1」の期待値を満たす手段がない。
- `AuditTrailService`（`.../security/audit/AuditTrailService.java:19-84`）は DB 永続化のみで JMS 連携を持たず、`SessionOperation` から直接呼べる API も不足している。Legacy `session/AppoServiceBean` と同じ構成のままなので、モダナイズ後の Trace/Gate 要件が反映されていない。

**実装方針（案）**
1. **SessionOperationInterceptor cleanup**: HTTP 層で決まった remoteUser / facilityId / clientIp / headers を `LogFilter` から `SessionInvocationContextHolder`（新規）へ格納し、`SessionOperationInterceptor` が `traceManager.start(...)` する際に `attributes` へ転写する。`finally` ブロックでは `SessionInvocationContextHolder#clear()` まで実施し、Appo/Schedule の長時間トランザクションでも MDC が汚染されないようにする。
2. **AuditTrailService#write 追加**: 既存 `record` をラップし、`AuditEvent` を返すだけでなく `AuditEventEnvelope`（シリアライズ可能 DTO）を生成するユーティリティを提供する。`write` は (a) actor 情報（remoteUser, facilityId, role）を `SessionTraceContext` の attributes から解決、(b) `requestId` に traceId を強制し、(c) `details` へ `SessionOperationInterceptor` で拾った `operation`, `component`, `args` を格納する役目を持たせる。
3. **SessionAuditDispatcher（新規）**: `@ApplicationScoped` で `AuditTrailService` と `MessagingGateway`（もしくは `JMSContext`）を受け取り、セッション層から `dispatcher.record(action, resource, domainDetails, patientId)` を呼ぶだけで Audit → JMS が連鎖する仕組みを用意する。JMS には `AuditEventEnvelope` を `ObjectMessage` として `java:/queue/dolphin` へ put し、`MessageSender` に `handleAuditEvent(AuditEventEnvelope, traceId)` を追加して証跡ログを残す。
4. **Appo/Schedule からの呼び出し**:
   - `AppoServiceBean#putAppointments` で状態ごとに `APPOINTMENT_CREATE/UPDATE/DELETE` を判定し、`dispatcher.record(..., Map.of("appointmentId", model.getId(), "karteId", model.getKarte().getId(), "state", state))` を呼ぶ。
   - `ScheduleServiceBean#getPvt` は read-only なので `SCHEDULE_FETCH` アクションとして 1 リクエスト 1 行の Audit を記録する（患者一覧を details に含めず、`patientVisitCount` 等のメタデータのみ保存）。`makeScheduleAndSend` / `removePvt` では `SCHEDULE_CREATE` / `SCHEDULE_DELETE` を送り、Claim 送信が走った場合は既存の `messagingGateway.dispatchClaim` ログとは別に Audit/JMS を残す。
5. **TraceId 伝搬**: `SessionTraceManager` に `setAttribute(String key, String value)` を追加し、`LogFilter` や REST リソース側で `sessionTraceManager.start` 済みか確認してから `actorId`, `facilityId`, `ipAddress`, `userAgent` を attributes に書き込む。`SessionAuditDispatcher` は attributes を `AuditEventPayload` へ展開する。

#### レビュー指摘（2025-11-12）
- `AppoServiceBean#putAppointments`（`server-modernized/src/main/java/open/dolphin/session/AppoServiceBean.java:39-95`）と `ScheduleServiceBean` の各メソッド（例: `getPvt` 116-180 行, `removePvt` 410-450 行）が失敗監査を記録した直後に `RuntimeException` を再送出しているため、同一トランザクション扱いの `AuditTrailService#write`（`server-modernized/src/main/java/open/dolphin/security/audit/AuditTrailService.java:60-74`）が生成した失敗監査レコードは JTA ロールバックとともに破棄される。`@TransactionAttribute(REQUIRES_NEW)` などで監査書き込みを分離しない限り、`failure(ex)` を付与しても DB/JMS には残らない。
- 現行差分では `AuditEventEnvelope` へ actor/request コンテキストをまったく設定しておらず（`builder("APPOINTMENT_MUTATION", "AppointmentModel").details(...)` だけ）、`AuditTrailService#write` も `SessionTraceContext` から補完していないため、`d_audit_event` の `actor_id`/`request_id`/`ip_address`/`patient_id` が常に `NULL` になる。`docs/web-client/ux/legacy/ONE_SCREEN_LAYOUT_GUIDE.md` で求めている「誰がどの患者の予約を操作したか」を判別できず、JMS 側で `AuditEventEnvelope` を relay しても匿名イベントとして扱われる。
- `ScheduleServiceBean#removePvt` の監査 details は `auditDetails.put("deletedDocuments", cnt)`（同 438-445 行）で PVT 削除 1 件を含む `cnt` を「削除ドキュメント数」として記録してしまう。`list.isEmpty()` 分岐でも PVT 削除済みにもかかわらず `deletedDocuments=0` を報告しており、Evidence 側で `deletedDocuments` を見ても実際に消えた visit/doctument 件数を再現できない。PVT 削除とカルテ削除件数を分けて記録する案に差し替える必要がある。
- JMS 連携は今回の差分でも未着手で、`AuditTrailService#write` が返す `AuditEventEnvelope` をどこにも publish していない。`SessionAuditDispatcher` が未実装のままでは `TRACEID_JMS_RUNBOOK.md §5.5` の messages-added 期待値が満たせないため、「Appo=+1 / Schedule=±0」を検証するための次工程を別途起票する。

#### 2025-11-12 対応内容
- `AuditTrailService` を `@Transactional(Transactional.TxType.REQUIRES_NEW)` 化し、Appo/Schedule からの監査書き込みが親トランザクションに引きずられないよう分離。`LogFilter` → `SessionOperationInterceptor` へ `remoteUser`/traceId を MDC 経由で連携し、`SessionTraceManager#putAttribute` で `actorId`/`requestId`/`patientId` を Attribute に乗せられるようにした。
- `AuditEventEnvelope.Builder` は actorId/traceId を必須フィールドとして検証し、requestId 未設定時は traceId をフォールバックで採用する。`AppoServiceBean` / `ScheduleServiceBean` は `SessionTraceContext` から actorId/requestId/traceId を解決し、患者単位の処理では `SessionTraceAttributes.PATIENT_ID` を更新してから監査レコードを生成する（複数患者にまたがる場合は `patientId=N/A`/`MULTIPLE` を明示）。
- `ScheduleServiceBean#removePvt` の details を `pvtDeletedCount` と `documentsDeletedCount` へ分割し、カルテが見つからない場合は `documentsDeletedStatus=noDocumentsForStartDate`、既に削除済みの場合は `documentsDeletedStatus=documentsAlreadyDeleted` を残すように変更した。Evidence から 0 件理由を復元できる。

**テスト / RUN_ID 計画**
- `TRACEID_JMS_RUNBOOK.md §5.5` のテンプレに従い、`RUN_ID=20251115TappoSchedPlanZ` を再利用する。Appo: `ops/tools/send_parallel_request.sh --profile compose --run-id 20251115TappoSchedPlanZ PUT /appo parity-appo-audit`、Schedule: `... GET /schedule/pvt/2025-11-09 parity-schedule-audit`。Evidence は `artifacts/parity-manual/{appo,schedule}/20251115TappoSchedPlanZ/` 直下に `d_audit_event_{legacy,modern}.tsv` と `logs/jms_dolphinQueue_read-resource.{before,after}.txt` を保存する。
- 期待値: Appo は Legacy/Modernとも `d_audit_event` に `APPOINTMENT_*` 行が 1 行以上追加され、JMS `messages-added` が +1。Schedule は Audit に `SCHEDULE_FETCH` と `patientVisitCount` が記録され、JMS は before/after 変化なし（差分 0 を README で明示）。
- CLI で利用するヘッダーは `tmp/parity-headers/{appo,schedule}_20251115TappoSchedPlanZ.headers`（`X-Trace-Id: trace-audit-{appo|schedule}-20251115TappoSchedPlanZ`）を新設し、`ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` に追記して Evidence 一覧の単一ソースにする。

**実装メモ（2025-11-12 差分草案）**
- **適用予定ファイル**: `common/src/main/java/open/dolphin/audit/{AuditEventEnvelope,AuditTrailService}.java`（セッション層と JMS の橋渡し DTO/API）、`server-modernized/src/main/java/open/dolphin/security/audit/AuditTrailService.java`（`write` 実装と `record` 連携）、`server-modernized/src/main/java/open/dolphin/session/{AppoServiceBean,ScheduleServiceBean}.java`（成功/失敗双方で `auditTrailService.write(...)` を呼び出す集約メソッド）を追加・改修する。`SessionAuditDispatcher` は次フェーズで実装する前提だが、今回の差分で `AuditEventEnvelope` を返す形にして後続の JMS 連携が差し込みやすい構造にそろえる。
- **差分管理**: `patches/appo_schedule_audit_plan.diff` に PR 向けコード案を保存。レビューでは (1) `AuditTrailService#write` の生成物が `AuditEventPayload` と 1:1 で同期されること、(2) `AppoServiceBean#putAppointments`／`ScheduleServiceBean#getPvt/makeScheduleAndSend/removePvt` のいずれでも例外経路で `Outcome=FAILURE` が記録されること、(3) 既存 `record` 呼び出しを壊していないことを確認する。
- **テスト想定**:
  1. `ops/tools/send_parallel_request.sh --profile compose --run-id 20251115TappoSchedPlanZ PUT /appo parity-appo-audit` を実行し、`d_audit_event_{legacy,modern}.tsv` に `APPOINTMENT_MUTATION` が追加されること、`logs/jms_dolphinQueue_read-resource.{before,after}.txt` の `messages-added` が +1 になることを確認。
  2. `... GET /schedule/pvt/2025-11-09 parity-schedule-audit` で `SCHEDULE_FETCH`／`SCHEDULE_CREATE`／`SCHEDULE_DELETE` が `details.resultCount` や `deletedDocuments` を伴って記録されることを検証。Claim 送信を伴うシナリオでは `dispatchClaimAsync` が呼ばれる経路の WARN/ERROR が無いか `logs/modern_trace.log` に併せて残す。
  3. `ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` に追加した `rest_audit_{appo,schedule}_trace` ケースを worker で実行し、TraceId／Audit／JMS の 3 点セットを `artifacts/parity-manual/{appo,schedule}/20251115TappoSchedPlanZ/` に保存してフェーズ4-2 Checklist をクローズする。

**オープン課題**
- `SessionOperationInterceptor` を経由しない REST 資産（`SystemResource` 等）が `AuditTrailService#write` を使う場合の互換レイヤーを設計する。既存 `record` API を残しつつ、`TouchAuditHelper` / `PhrAuditHelper` から段階的に差し替える。
- JMS 側で `AuditEventEnvelope` を受信した後のシンク（外部 SIEM, DataLake など）が未定。暫定的には `MessageSender#handleAuditEvent` で `LOGGER.info("AUDIT_EVENT [traceId=...]")` を残すだけとし、実運用シナリオはフェーズ5の Observability Gate で詰める。
- Legacy 側も同じ `dispatcher` を適用しないと parity が崩れるため、`server/src/main/java/open/dolphin/session/AppoServiceBean` ほかにも `@SessionOperation` 相当の AOP を追加するか、少なくとも `d_audit_event` と JMS の取得スクリプトで「Legacy は空のままで良い」条件を再定義する必要がある。

#### Java8 互換対応（2025-11-12 夜間追加）
- `opendolphin-common` を JDK 8 で個別ビルドできるよう、`AuditTrailService` が持っていた `private` インターフェースメソッドを `default systemEnvelope(...)` へ置き換え、`Map.of()` 依存を `Collections.emptyMap()` へ差し替えた。必須フィールド検証は `requireNonBlank` を通じて default メソッド側で先に弾き、従来どおり `writeSuccess`/`writeFailure` から一貫したエンベロープを返す。
- `AuditEventEnvelope.Builder#build` の `String#isBlank()` 依存を排除し、Java 8 互換の `isNullOrBlank` ヘルパーへ差し替えた。actorId/traceId の必須チェックは `AuditTrailService` からの生成段階でもう一度バリデートし、他レイヤー（Appo/Schedule 等）で Builder を直に呼ぶ場合でも従来例外を維持できるようにしている。
- フィックス差分は `patches/audit_trail_java8_fix.diff` に保存し、`mvn -rf :opendolphin-common -DskipTests compile` の結果を `artifacts/parity-manual/build/audit_trail_java8_fix/mvn-compile.log` へ採取済み。今後 `common` 単体を Java 8 で再ビルドする際は同 RUN_ID を再利用し、ログが更新されたら本節と `PHASE2_PROGRESS.md` を同期させる。

#### 実機確認（RUN_ID=`20251115TappoSchedPlanZ`）
- helper コンテナ + `--profile modernized-dev` で `rest_audit_{appo,schedule}_trace` を実行し、`tmp/reseed_appo.sql` による `d_appo id=8001` 復元を組み合わせて監査/JMS を採取。
- Appo: `SessionAuditDispatcher` が `AuditTrailService#write` の戻り値を JMS `java:/queue/dolphin` へ publish し、Modern `d_audit_event` に `APPOINTMENT_MUTATION`（成功/失敗）が `actor_id=1.3.6.1.4.1.9414.72.103:doctor1`, `request_id=trace-audit-appo-20251115TappoSchedPlanZ` 付きで 4 行追記。JMS は `messages-added=4L→5L` を `artifacts/parity-manual/appo/20251115TappoSchedPlanZ/logs/jms_dolphinQueue_read-resource*.txt` で確認。
- Schedule: `GET /schedule/pvt/2025-11-09` が Legacy/Modern とも 200 かつ `SCHEDULE_FETCH` 監査 1 行ずつを記録。JMS enqueue は発生せず、`messages-added` は before/after で変化 0（証跡: `artifacts/parity-manual/schedule/20251115TappoSchedPlanZ/logs/jms_dolphinQueue_read-resource*.txt`）。

### 3.5 Maven DuplicateProjectException 調査（2025-11-12 完了）
- **RUN_ID=`20251116TreactorFixZ1`**: `mvn -f pom.server-modernized.xml -pl server-modernized -am help:effective-pom -DskipTests` → `... package -DskipTests` を連続実行し、どちらも `Project "opendolphin:opendolphin-server:2.7.1" is duplicated in the reactor` を再現せず完走した。ログは `artifacts/parity-manual/build/duplicate_project/20251116TreactorFixZ1/{help_effective_pom.log,mvn_package.log}`、`server-modernized/target` の成果物一覧は `server-modernized-target-ls.txt` へ保存。
- **原因と恒久策**: Legacy `server/pom.xml` は `artifactId=opendolphin-server` を維持しつつ、Modernized `server-modernized/pom.xml` を `artifactId=opendolphin-server-modernized`（`<build><finalName>opendolphin-server</finalName>` 付き）へ固定。ルート `pom.xml` と `pom.server-modernized.xml` の `<modules>`／`<dependencyManagement>` から重複参照や profile 経由の二重登録が無いことを再点検し、Modernized reactor には `common` / `reporting` / `server-modernized` のみが含まれるよう整理した。これにより `mvn -f pom.server-modernized.xml -pl server-modernized -am <goal>` とルート `mvn -pl server-modernized <goal>` の双方で DuplicateProjectException が再発しないことを確認済み。
- **副次修正**: `AppoServiceBean#getAppointmentList` 終了後に残っていた不要な `}` を削除し、Java 17 で暗黙クラス扱いになる不具合を解消。`mvn -f pom.server-modernized.xml -pl server-modernized -am package -DskipTests` のログでコンパイルが通ることを確認した。
- **再発防止メモ**: Modernized 単体ビルド／静的解析を行う際は必ず `mvn -f pom.server-modernized.xml -pl server-modernized -am <goal> -DskipTests` で実行し、ルート `pom.xml` のリアクターに Legacy `server` を巻き込まない。`itext-font` や `AppleJavaExtensions` など manual JAR が解決できない場合は `docs/web-client/architecture/REPOSITORY_OVERVIEW.md` 記載の `mvn install:install-file` 手順でローカル登録してから再取得する。
- **2025-11-12 23:40JST 追記（RUN_ID=`20251116ThealthInsZ1`）**: `server-modernized/pom.xml` の `opendolphin-reporting` / `opendolphin-common (classifier=jakarta)` を dependencyManagement でピン留めし、`mvn -f pom.server-modernized.xml -pl server-modernized -am package -DskipTests` → `jar tf server-modernized/target/jakarta-libs/opendolphin-common-*-jakarta.jar | rg HealthInsuranceModel` を再取得 (`artifacts/parity-manual/HEALTH_INSURANCE_MODEL_FIX/20251116ThealthInsZ1/{mvn_package.log,jar_common_healthinsurance_after_fix.log}`)。`docker cp server-modernized/target/opendolphin-server.war opendolphin-server-modernized-dev:/opt/jboss/wildfly/standalone/deployments/` → `touch .../opendolphin-server.war.dodeploy` によるホットデプロイ（`docker_cp_hotdeploy.log`）と、`docker exec -e PGPASSWORD=opendolphin opendolphin-postgres-modernized psql -c '\\d+ d_health_insurance'` / `SELECT id, patient_id, beanbytes FROM d_health_insurance ...`（`psql_healthinsurance_model.log`）で `HealthInsuranceModel` OID テーブルの存在を確認。`ops/modernized-server/docker/Dockerfile` と `scripts/start_legacy_modernized.sh` の BuildKit ステージに `COPY reporting ./reporting` が残っていることも再点検し、WSL2 制約下でも WAR 差し替えのみで恒久対応できることを確認した。

#### Legacy WAR 未生成の原因整理（RUN_ID=`legacy_war_missing`, 2025-11-12）
- 事象: `scripts/start_legacy_modernized.sh start --build` で Legacy 側の multi-stage build (`server build 20/20`) が `maven-compiler-plugin:2.3.2:compile` で停止し、`server/target/opendolphin-server-*.war` が作成されず Docker が `mv server/target/opendolphin-server-*.war ...` へ到達しない。BuildKit ログは `tmp/start_legacy_modernized_20251111TclaimfixZ3.log` に保存済み。
- エラー1: `AuditTrailService`（`server/src/main/java/open/dolphin/security/audit/AuditTrailService.java:30`）で `TypedQuery<String>` が解決できず `interface TypedQuery` が見つからない。Legacy プロファイル（`pom.server-classic.xml` + `-Plegacy-wildfly10`）は `javaee-web-api:7.0` だけに依存しており、BuildKit レイヤーでは `javax.persistence-api` がクラスパスに入らない。2025-11-12 20:29 JST 時点で `server/pom.xml` へ `javax.persistence:javax.persistence-api:2.2`（scope=provided）を追加し、`mvn -f pom.server-classic.xml -pl server -am -Plegacy-wildfly10 -DskipTests package` が成功すること（`artifacts/parity-manual/build/legacy_war_missing/mvn-package-server.fix.log`）と `dependency:tree -Dincludes=javax.persistence:javax.persistence-api` に同依存が表示されること（`artifacts/parity-manual/build/legacy_war_missing/mvn-deptree-server.fix.log`）を確認済み。
- エラー2（解消済, 2025-11-12 22:10 JST）: `StampResource.java` / `StampServiceBean.java` が `LOGGER.log(Level, () -> "...", exception)` など Java 9 以降のサプライヤー版シグネチャを呼び出していたため、Legacy ビルド（`source/target=1.8`）で `maven-compiler-plugin:2.3.2` がコンパイルに失敗していた。両クラスへ `formatStampTreeFailureMessage` / `formatVersionMismatchMessage` を追加して `LOGGER.log(Level, message, ex)` 形式へ戻し、Legacy/Modernized の双方を同一ロジックに揃えた。差分は `patches/legacy_stamp_logger_fix.diff` に保存し、`mvn -f pom.server-classic.xml -pl server -am -Plegacy-wildfly10 -DskipTests package` の再実行ログを `artifacts/parity-manual/build/legacy_war_missing/mvn-package-stamp-logger.log` へ追記済み。`server/target/opendolphin-server-2.7.1.war` の更新時刻とハッシュは `artifacts/parity-manual/build/legacy_war_missing/server-target-ls.txt` で確認できる。
- 切り分け: 手元で `sed '/<module>server-modernized<\/module>/d' pom.xml > pom.server-classic.xml` を再生成し、`mvn -f pom.server-classic.xml -pl server -am -Plegacy-wildfly10 -DskipTests package` を実行したところ `server/target/opendolphin-server-2.7.1.war` が生成された（`artifacts/parity-manual/build/legacy_war_missing/mvn-package-server.log`、`server-target-ls.txt`）。`server/pom.xml` は `<finalName>` を定義していないため成果物は `opendolphin-server-2.7.1.war` となり、Dockerfile 内の `WAR_BASENAME=opendolphin-server` は `mv ... *.war -> opendolphin-server.war` で吸収できることを確認した。
- ToDo:
  1. [x] `server/pom.xml` に `javax.persistence-api` を追加 → Legacy build stage で `TypedQuery` が必ず解決される状態にし、再度 `scripts/start_legacy_modernized.sh start --build` を実行して `artifacts/parity-manual/build/legacy_war_missing/` に成功ログを追記（`mvn-package-server.fix.log`, `mvn-deptree-server.fix.log`）。
  2. [x] `StampResource` / `StampServiceBean` の `LOGGER.log` 呼び出しを Java 8 互換に戻したパッチを `patches/legacy_stamp_logger_fix.diff` として保存し、`docs/server-modernization/phase2/operations/TRACEID_JMS_RUNBOOK.md` から参照できるようにする（旧ファイル名 `stamp_audit_java8_fix.diff` を廃止）。
  3. [ ] Legacy build 成功後は `artifacts/parity-manual/build/legacy_war_missing/README.md`（未作成）に「再現条件・証跡ファイル一覧・WAR 名が変わらない理由（`WAR_BASENAME` + rename）」をまとめ、`PHASE2_PROGRESS.md` と本節でリンクする。

### trace_http 再取得結果（RUN_ID=20251111TtracefixZ）
- 2025-11-11 01:16 JST に helper コンテナ（`buildpack-deps:curl`）から compose プロファイルを実行し、`PARITY_OUTPUT_DIR=artifacts/parity-manual/TRACEID_JMS/20251111TtracefixZ` に `trace_http_{400,401,500}` を保存。`trace_http_200` は RUN_ID=`20251111T091717Z` を継続利用。
- Legacy 400=400 (`param must contain ...`), 401=401（HTML `Unauthorized`）, 500=500（`Karte result is empty`）。Modernized 400=500（`RollbackException`）, 401=403（`Forbidden`）, 500=500（`Karte result is empty: pid lookup`）。`legacy_trace_http.log` / `modern_trace_http.log` に `trace-http-*-20251111TtracefixZ` が記録されているが、`d_audit_event_latest.tsv` は旧 RUN（ID=54/55）のままで JMS も 0 件。
- Evidence: `trace_http_{400,401,500}/{legacy,modern}/` と `logs/{send_parallel_request.log,legacy_trace_http.log,modern_trace_http.log,logfilter_env.txt,d_audit_event_latest.tsv,jms_dolphinQueue_read-resource.txt}`。Audit/JMS 未到達である旨を `TRACEID_JMS_RUNBOOK.md §5.4` と照合。

## 4. Touch / Karte パリティ設計メモ（2025-11-11 点検）

### 4.1 TouchRequestContextExtractor / TouchAuthHandler の現状
- `TouchRequestContextExtractor` は `HttpServletRequest#getRemoteUser()` → `userName` ヘッダー → `X-Facility-Id` / `facilityId` の順に principal を復元し、`facilityId + '@' + userId` 形式を強制している。`ANONYMOUS_PRINCIPAL` や空文字は即座に `null` 扱いになるため、facility ヘッダーが空のまま `trace_http_401`（パスワード欠落）を送ると `IllegalStateException("Remote user is not available.")` や `Remote user does not contain facility separator` で 500 になる。Legacy はヘッダーのみでも 401 まで進めていたので、モダナイズ側では facility ヘッダーだけで `remoteUser=fid@doctor1` を合成し、401 までは `TouchAuthHandler` に制御を渡す fallback が必要。
- `TouchAuthHandler` は `X-Facility-Id` を大文字正規化し、`remoteUser` の施設部分と一致しない場合は 403 を返す。`remoteUser` を取得できない場合でも `X-Facility-Id` / `facilityId` ヘッダーを fallback として返すが、Extractor が例外を投げるとここまで到達しない。匿名ユーザーや facility header のみで来るリクエストでは (1) `sanitizePrincipal` で null になってもヘッダーから userId を補完する、(2) fallback 実行時に `Level.FINE` ログへ traceId と facility を残して `TRACE_PROPAGATION_CHECK.md` の証跡と突合できるようにする、といった設計メモを残す。

### 4.2 KarteResource / Converter の 500 起因
- `KarteResource#getKarteByPid` は `getRemoteFacility(servletReq.getRemoteUser())` の戻り値をそのまま `karteServiceBean.getKarte(fid, pid, fromDate)` へ渡すため、`remoteUser` が facility 区切りを欠いていると `fid=null` のままサービス層を呼び出し、`NullPointerException` か `IllegalArgumentException` で 500 になる。`trace_http_500`（`GET /karte/pid/INVALID,%5Bdate%5D`）では `X-Trace-Id=trace-http-500` を付けたヘッダーが `TRACEID_JMS/20251111T091717Z/trace_http_500/` に残っており、Legacy=200/Modern=400 の不一致が継続中。
- `KarteBeanConverter` も `setModel(null)` を許容せず、Jackson/JAXB が `getId()` などを呼ぶ段階で `NullPointerException` になる。`KarteServiceBean` が null を返した場合は 404/204 にフォールバックするか、Converter 側で null モデルを `Optional` 的に扱うメソッドを追加し、患者メモや DocInfo のリストも `Collections.emptyList()` でシリアライズする方向で整理する。

### 4.3 テスト・証跡方針
- `trace_http_401`: `ops/tests/api-smoke-test/headers/trace-session.headers` をコピーした `tmp/trace-headers/trace_http_401.headers` から `password` 行を削除し、Touch fallback 実装後に `artifacts/parity-manual/TRACEID_JMS/<next-run>/trace_http_401/` を採取。`logs/logfilter_env.txt` と `logs/{legacy,modern}_trace_http.log` に remoteUser 合成ログを必ず残す。
- `trace_http_500`: `trace-session.headers + X-Trace-Id: trace-http-500` を用い、`KarteBeanConverter` null-safe 化後に `artifacts/parity-manual/TRACEID_JMS/<next-run>/trace_http_500/{legacy,modern}/` を差し替える。完了後は `artifacts/parity-manual/TRACEID_JMS/20251111T091717Z/` をベースライン、`<next-run>` を最新版として README / Runbook に Evidence を追記する。
- Touch/Karte の再取得結果は `PHASE2_PROGRESS.md` の TODO と `rest_error_scenarios.manual.csv`（`rest_error_{unauthorized,internal}`）に RUN_ID を併記し、`artifacts/parity-manual/TRACEID_JMS/<next-run>/logs/send_parallel_request.log` と `artifacts/parity-manual/db/<next-run>/d_audit_event_seq_validation.txt` で TraceId / Audit をセットで参照できるようにする。

## 4. 予約/予定カルテ/紹介状/ラボ/スタンプ REST parity（RUN_ID=`20251110TnewZ`）

- `docker run --rm --network legacy-vs-modern_default -v "$PWD":/workspace -w /workspace buildpack-deps:curl bash -lc 'BASE_URL_LEGACY=\"http://server:8080/openDolphin/resources\" BASE_URL_MODERN=\"http://server-modernized-dev:8080/openDolphin/resources\" … ops/tools/send_parallel_request.sh …'` で CLI を実行。作業ホストから `localhost:{8080,9080}` へ直接アクセスできないため、Compose ネットワーク上の `server` / `server-modernized-dev` を参照する手順を `LEGACY_MODERNIZED_CAPTURE_RUNBOOK.md` §3.1 に再確認した。
- Legacy `LogFilter` は MD5 パスワードでキャッシュ照合するため、`password: 632080fabdb968f9ac4f31fb55104648` をヘッダーに設定。`tmp/parity-headers/<case>_<RUN_ID>.headers` で `X-Trace-Id: parity-<case>-<RUN_ID>` を発行し、`PUT` 系 API（appo/letter/stamp）は `Content-Type: application/json` を明示した。
- 取得物は `artifacts/parity-manual/{appo|schedule|letter|lab|stamp}/20251110TnewZ/` に集約し、`logs/{legacy,modern}_trace.log`・`logs/modern_trace_context.log`（500 stack trace）・`d_audit_event_{legacy,modern}.txt`・`jms_note.txt` を同梱した。前 RUN（`20251110T234440Z`）の証跡も比較用に保持している。
- **GET 公開系 404 の原因候補（2025-11-12 切り分け）**
  - **REST 実装なし**: Legacy / Modernized 双方の `StampResource` には `/stamp/tree/{facility}/{public|shared|published}` が定義されておらず、`@GET` メソッドは個人ツリー (`/stamp/tree/{userPK}`) と `/stamp/published/tree` のみ。`server/src/main/java/open/dolphin/rest/StampResource.java` と `server-modernized/src/main/java/open/dolphin/rest/StampResource.java` どちらにも公開系ルートが無いため、JAX-RS が 404 を返している。
  - **WildFly URL パターン**: Legacy 側 `WEB-INF/web.xml` では `resteasy.servlet.mapping.prefix=/resources` と `/resources/*` の `url-pattern` が設定済みで、`StampResource` も `resteasy.resources` に含まれる。Modernized 側も Jakarta 版 `web.xml` が同構成のため、サーブレット設定差分が原因ではない。
  - **facility ID マッピング**: `StampServiceBean#getPublishedTrees(String fid)` は facility ID を受け取り Local+Global 公開ツリーを返すが、現行の REST は `getRemoteFacility(remoteUser)` の結果しか渡さない。`/stamp/tree/{facility}/<variation>` を実装する際は、パスの facility と `remoteUser` の facility が一致するかを検証し、不一致なら 403 を返す等のガードが必要。


| API / ServiceBean | Legacy | Modernized | 監査 / JMS | 次アクション |
| --- | --- | --- | --- | --- |
| `PUT /appo` (`AppoServiceBean#putAppointments`) | 200（`response=1`） | 200（`response=1`） | `d_audit_event` は両環境とも空、JMS 発火なし。 | `tmp/reseed_appo.sql` を Runbook に常設したので、TraceId 付き監査/JMS を SessionOperation から送出できるよう実装を継続。 |
| `GET /schedule/pvt/2025-11-09` (`ScheduleServiceBean`) | 200（`list` に `架空 花子` 1 件） | 200（同 `架空 花子` 1 件） | Legacy/Modern 共に `SYSTEM_ACTIVITY_SUMMARY` のみ。 | Elytron/JACC で `remoteUser` は復旧したが AuditTrail がゼロのまま。`d_audit_event` 記録を優先度高で対応。 |
| `PUT /odletter/letter` (`LetterServiceBean`) | 200 （ID=18） | 200（ID=-38） | Legacy: `d_audit_event` 空 / JMS 0L → 0L。Modern: `LETTER_CREATE` が TraceId=`trace-letter-audit-<RUN_ID>` で記録され `messages-added` が 0L→1L。 | **2025-11-12:** RUN_ID=`20251115TletterAuditZ1`（`artifacts/parity-manual/letter/20251115TletterAuditZ1/`）で `SessionAuditDispatcher` により Audit→JMS 連携を確認。`logs/d_audit_event_letter_modern.tsv` では `mutationType=create`・`karteId`・`consultantHospital` 等の details を保持。Legacy は `AuditTrailService` 未連携のため引き続きゼロ。 |
| `GET /lab/module/WEB1001,0,5` (`NLabServiceBean`) | 404（seed 未適用時） | 200（`{"list":[]}`） | Legacy: 監査/JMS 0 行。Modern: `LAB_TEST_READ` が TraceId=`trace-lab-audit-<RUN_ID>` で記録され `messages-added` が 1L→2L。 | **2025-11-12:** RUN_ID=`20251115TlabAuditZ1`（`artifacts/parity-manual/lab/20251115TlabAuditZ1/`）で CRUD パスに `SessionAuditDispatcher` を導入。details には `patientId`/`facilityId`/`labCode`/`resultCount` を格納。Legacy 側は `d_nlabo_module` seed 未適用のため 404 挙動を Evidence に記載し、シード投入後の再取得を TODO に残す。 |
| `PUT /stamp/tree` (`StampServiceBean`) | 200（`stamp_tree_payload.json` を GET `/stamp/tree/9001` の最新版へ同期し、`ops/db/local-baseline/stamp_tree_oid_cast.sql` を Legacy DB へ適用した状態で Audit/JMS も記録）。 | 200（`d_subscribed_tree` 作成＋`bytea_to_oid` 再適用＋`StampServiceBean#persistPersonalTree` ロックで `UnknownEntity`/500 を解消。`StampResource` WARN ログに version desync を残しつつ Audit/JMS を同じ TraceId で記録）。 | Legacy/Modern: `logs/d_audit_event_stamp_{legacy,modern}.tsv` で `STAMP_TREE_PUT`（TraceId=`parity-stamp-20251111TstampfixZ3`）を確認。Modern `logs/jms_dolphinQueue_read-resource.txt` は `messages-added=4L`, `message-count=0L`。Legacy JMS も `read-resource(include-runtime=true)` で 0 件キューを維持。 | RUN_ID=`20251111TstampfixZ3`（`artifacts/parity-manual/stamp/20251111TstampfixZ3/`）を新基準とし、`rest_error_stamp_data_exception` の期待値・ヘッダー類（`tmp/parity-headers/stamp_20251111TstampfixZ3.headers`）を更新済み。 |

**Letter/Lab 監査結果（2025-11-12 JST）**
- RUN_ID=`20251115TletterAuditZ1`: `SessionAuditDispatcher` 経由で Modern `d_audit_event` に `LETTER_CREATE`（id=82, TraceId=`trace-letter-audit-20251115TletterAuditZ1`）を追加し、`logs/jms_dolphinQueue_read-resource.{before,after}.txt` の `messages-added` が 0L→1L。Legacy は Audit/JMS が未連携のため 0 行で維持し、Evidence に Known Issue として記録。
- RUN_ID=`20251115TlabAuditZ1`: Modern `LAB_TEST_READ`（id=84, `patientId=WEB1001`, `resultCount=0`）を記録し、`messages-added` が 1L→2L。Legacy は `d_nlabo_module` seed 未適用のため 404 応答だが、再取得条件を README / rest_error CSV に明記して Evidence に差分理由を残した。

- **実装ハイライト**
  - `server-modernized/src/main/java/open/dolphin/security/audit/AuditTrailService.java` を CDI (`@ApplicationScoped + @Transactional(REQUIRES_NEW)`) 化し、`SessionAuditDispatcher` からそのまま Audit→JMS を連鎖できるようにした。
  - `LetterServiceBean` / `NLabServiceBean` に `recordLetterMutation` / `recordLabAudit` を追加し、`SessionTraceManager` から `actorId`/`facilityId`/`patientId` を必ず補完したうえで `SessionAuditDispatcher` を呼び出す。details には `mutationType`, `itemCount`, `labCode`, `resultCount` など監査に必要なフィールドを格納。
  - `LetterResource#putLetter` / `NLabResource` に `@SessionOperation` を付与し、REST 呼び出し単位で TraceId・actorId を確実に初期化する。
  - `MessageSender` は `AuditEventEnvelope` を JMS から受信した場合でも action/outcome を INFO ログへ記録し、診断を容易にした。

- **実装ステップ（呼び出し位置・データ補完・JMS 連携）**
  - **LetterServiceBean（PUT /odletter/letter）**: `server-modernized/src/main/java/open/dolphin/session/LetterServiceBean.java` の `saveOrUpdateLetter` 終了直前で `AuditTrailService` を呼び出し、`linkId` > 0 の場合は `LETTER_UPDATE`、新規作成時は `LETTER_CREATE` として `AuditEventEnvelope` を生成する。`resolveKarteReference` 済みの `karteId` / `patientId` / `letterType` / `consultantHospital` / `sendClaim` フラグ（DocInfoModel とのリレーションから補完）を `details` へ格納し、`SessionTraceManager` から取得した `traceId`・`actorId`・`operation` を `SessionAuditDispatcher`（次フェーズ導入予定）に渡せるよう `auditTrailService.write(...)` の戻り `AuditEventEnvelope` を保持する。
  - **Letter sendClaim → JMS**: `LetterResource`（`server-modernized/src/main/java/open/dolphin/rest/LetterResource.java`）で `putLetter` 完了後に `model.getDocInfoModel().isSendClaim()` を再評価し、true の場合は `MessagingGateway.dispatchClaim(DocumentModel)` を呼ぶ前に `LetterAuditHelper#recordSendClaim`（新規）で `EHT_CLAIM_SEND` 相当の Audit/JMS を強制。`reset_d_audit_event_seq.sql` を適用した直後のシーケンス値を `details.auditEventSeqBefore` に含め、`d_audit_event` と JMS の突合を容易にする。
  - **NLabServiceBean（GET /lab/module/* および /lab/item/*）**: `server-modernized/src/main/java/open/dolphin/session/NLabServiceBean.java` の `getLaboTest`・`getLaboTestItem`・`create`・`deleteLabTest` の各リターン前に `AuditTrailService` を注入し、`LAB_RESULT_FETCH`／`LAB_RESULT_CREATE`／`LAB_RESULT_DELETE` を記録する。`fidPid` 分解から `facilityId` / `patientId` を導出し、`details` には `sampleDateRange`・`resultCount`（0 件可）・`laboCenterCode` を格納する。Audit 呼び出しは結果件数 0 件でも必ず実行し、`SessionTraceContext` が未初期化のケースでは `LogFilter` → `SessionOperationInterceptor` の順に `actorId` を補完することで TraceId を欠かさない。
  - **Lab Audit → JMS**: `AuditTrailService#write` で得た `AuditEventEnvelope` を `SessionAuditDispatcher`（`AuditTrailService` から委譲する設計）経由で `java:/queue/dolphin` に `ObjectMessage` として publish し、`TRACEID_JMS_RUNBOOK.md` §5.8 で求められている `messages-added>0L` を `artifacts/parity-manual/lab/<RUN_ID>/logs/jms_dolphinQueue_read-resource*.txt` へ記録する。`details.resultCount` が 0 の場合も JMS を飛ばし、Legacy との差分（Legacy=0L 継続）の証跡として README に明記する。

### StampTree 移行フロー（d_subscribed_tree / OID cast / payload 図解）

```
GET /stamp/tree/9001 (helperコンテナ)
          |
          v
tmp/parity-letter/stamp_tree_payload.json -----> PUT /stamp/tree (TraceId=parity-stamp-<RUN_ID>)
          |                                             |
          |                                             v
          |                              artifacts/parity-manual/stamp/<RUN_ID>/logs/d_audit_event_stamp_*.tsv
          v
ops/db/local-baseline/stamp_tree_oid_cast.sql ----> Legacy & Modern Postgres (`bytea_to_oid` 再登録)
          |
          v
CREATE TABLE d_subscribed_tree (...) ------------> Modern Postgres (`logs/d_subscribed_tree_migration.txt`)
```

- **`d_subscribed_tree` 作成手順**: Modern DB で `CREATE TABLE d_subscribed_tree (id BIGSERIAL PRIMARY KEY, treeId BIGINT NOT NULL, user_id BIGINT NOT NULL REFERENCES d_users(id));` を実行し、`SubscribedTreeModel` の `@ManyToOne` 定義どおり `user_id` 外部キーを張る。`docker exec opendolphin-postgres-modernized psql -U opendolphin -d opendolphin_modern -c "\dt d_subscribed_tree"` で存在確認し、結果と `CREATE TABLE` ログを `artifacts/parity-manual/stamp/20251111TstampfixZ3/logs/d_subscribed_tree_migration.txt` へ保存する。Legacy 側は既存テーブルがあるため `\d d_subscribed_tree` のみで差分確認する。
- **`stamp_tree_oid_cast.sql` 再適用**: `docker exec opendolphin-postgres{,-modernized} psql -U opendolphin -d <db> -f ops/db/local-baseline/stamp_tree_oid_cast.sql` を順に実行し、`CREATE FUNCTION bytea_to_oid(bytea)` → `DROP/CREATE CAST (bytea AS oid)` の出力を `logs/d_stamp_tree_cast_migration.txt` に記録する。スクリプトは `treeBytes` を OID にキャストしたまま `lo_from_bytea` へ移行する恒久対策で、GET/PUT のどちらも 200 / Audit/JMS を維持する前提条件となる。
- **payload 更新履歴**: `tmp/parity-letter/stamp_tree_payload.json` は RUN_ID=`20251111TstampfixZ2` 時点で `versionNumber=4` へ同期し、`rest_error_stamp_data_exception` の PUT 200 を確認。`d_subscribed_tree` を追加してから再度 GET `/stamp/tree/9001` を取得し、RUN_ID=`20251111TstampfixZ3` で `versionNumber=11` へ更新した。`git diff tmp/parity-letter/stamp_tree_payload.json` と `artifacts/parity-manual/stamp/<RUN_ID>/stamp_tree_user9001/{legacy,modern}/response.json` を突き合わせ、差分が version と `treeBytes` のみであることを確認してから PUT を実行する。

- **タイムライン**
  - 2025-11-10 RUN_ID=`20251110TnewZ`: GET `/stamp/tree/9001` は `relation "d_subscribed_tree" does not exist` で停止。`payload` は Legacy から取得できず 500 証跡のみ保存。
  - 2025-11-11 RUN_ID=`20251111TstampfixZ2`: `stamp_tree_oid_cast.sql` を Legacy/Modern 双方へ適用し、`tmp/parity-letter/stamp_tree_payload.json`（version=4）で PUT 200 を確認（Legacy Audit/JMS のみ）。
  - 2025-11-12 RUN_ID=`20251111TstampfixZ3`: Modern DB に `d_subscribed_tree` を新設し、GET → payload version=11 → PUT → REST/Audit/JMS すべて 200/TraceId 揃いを記録。現時点のベースラインとして Appendix / Runbook へ反映済み。

RUN_ID=`20251111TstampfixZ3` の HTTP / headers / meta / `logs/*` は `artifacts/parity-manual/stamp/20251111TstampfixZ3/` に集約済み。Legacy/Modern とも `stamp_tree_user9001/`, `PUT_stamp_tree/`, `rest_error_stamp_data_exception/` を揃え、`logs/d_audit_event_stamp_{legacy,modern}.tsv` と `logs/jms_dolphinQueue_read-resource*.txt` で TraceId=`parity-stamp-20251111TstampfixZ3` の Audit/JMS を突合可能。旧 RUN（`20251111TstampfixZ2`）は Legacy Audit 未実装／GET 500 再現ログとして `artifacts/parity-manual/stamp/20251111TstampfixZ2/` に保持する。

#### Stamp PUT 500 是正案（2025-11-11 更新版）

- **型ミスマッチの整理**: Hibernate 6 では `@Lob byte[]` が PostgreSQL `oid` 型にマップされ、JDBC からは `long` の Large Object ハンドルを渡す前提となる。一方、Legacy DB／Flyway V0225／`ops/db/local-baseline/local_synthetic_seed.sql` は `treeBytes BYTEA` を定義しており、`StampTreeModelConverter` がシリアライズした Base64 → `byte[]` をそのまま INSERT しようとすると `Bad value for type long ... treeBytes` が発生する。`web-client/src/features/administration/pages/StampManagementPage.tsx` でも Base64 文字列（`encodeStampTreeXml`）を `treeBytes` に積んで PUT しているため、Modernized 側を BYTEA 対応に寄せる方がクライアント互換性を保ちやすい。
- **案A（推奨）: ORM 側で bytea 宣言を明示**  
  - `StampTreeModel` と `PublishedTreeModel` の `treeBytes` フィールドへ `@JdbcTypeCode(SqlTypes.BINARY)` と `@Column(name="treeBytes", columnDefinition="bytea")` を追加し、`@Lob` を除去または `@Lob` 併用に切り替える。Jakarta Persistence では `byte[]` + `@JdbcTypeCode(SqlTypes.BINARY)` を指定すると Hibernate が `bytea` に最適化された `BinaryJdbcType` を利用するため、既存 DDL を変更せずに `Bad value for type long` を解消できる。  
  - 既存データの再投入は不要だが、`common` モジュールの shaded jar を Legacy サーバーにもデプロイする必要がある点を `PHASE2_PROGRESS.md` / `DOC_STATUS.md` に記録する。JUnit では `JsonTouchResourceParityTest#putStampTree`（追記予定）を追加し、`treeBytes` round-trip を regression する。  
  - `StampTreeModelConverter` は JSON 化する際に `byte[]` を Base64 へエンコードするだけなので、追加アクションとして `setModel` 時に `model.getTreeXml()` が存在する場合 `model.setTreeBytes(model.getTreeXml().getBytes(StandardCharsets.UTF_8))` を共通化するヘルパを実装し、新 UI / Swing 双方で同じロジックを共有する。`client/src/main/java/open/dolphin/delegater/StampDelegater.java` や Web クライアントの `encodeStampTreeXml` は同振る舞いで揃える。
- **暫定キャスト（2025-11-12）**  
  - UnknownEntity が解消するまでの暫定策として、Legacy/Modern 双方で `ALTER TABLE d_stamp_tree ALTER COLUMN treebytes SET DATA TYPE oid USING lo_from_bytea(0, treebytes);` を実行し、`CREATE OR REPLACE FUNCTION bytea_to_oid(bytea)`＋`CREATE CAST (bytea AS oid)` を登録した。手順を `ops/db/local-baseline/stamp_tree_oid_cast.sql` に切り出し、`artifacts/parity-manual/stamp/20251111TstampfixZ3/logs/d_stamp_tree_cast_migration.txt` へ追記。恒久対応で bytea へ戻す際は各 RUN のログを参照する。
- **案B: DDL を OID へ揃える場合**  
  - 新しい Flyway（例: V0226）で `ALTER TABLE d_stamp_tree ALTER COLUMN treeBytes TYPE OID USING lo_from_bytea(0, treeBytes);` を実行し、`d_stamp_tree_seq` / seed も `lo_from_bytea` を用いる。`PublishedTreeModel` / `StampTreeModel` の `treeBytes` へ `@Lob @JdbcTypeCode(SqlTypes.BLOB)` を指定し、`stamp_tree_payload.json` などのテストデータは変換不要。  
  - ただし OID は Large Object カタログにガーベジを残すため `vacuumlo` 運用やバックアップ手順の更新が必要となり、`ops/tests/api-smoke-test/rest_error_scenarios.manual.csv` の期待結果も `oid` 前提へ書き換えるコストが発生する。
- **決定・フォローアップ**: 案A（ORM 側 bytea 宣言＋`persistPersonalTree` ロック）を採用し、`common` コンバータで `treeXml`→`treeBytes` 変換を統一。`StampResource` も AuditTrail 連携と TraceId WARN を追加済み。運用 Runbookでは GET→payload 更新フロー、`ops/db/local-baseline/stamp_tree_oid_cast.sql` / `CREATE TABLE d_subscribed_tree` の適用手順、`d_audit_event_id_seq` リセットログ（`artifacts/parity-manual/db/20251111TstampfixZ2/{legacy,modern}/`）を明記し、RUN_ID=`20251111TstampfixZ3` を Stamp parity の最新基準とする。Legacy への Audit/JMS バックポートは完了したため、残課題は Letter FK/JMS・Lab DTO/Audit・Touch/Karte Trace 伝搬のフォローに限定する。


- JMS は今回いずれも enqueue されなかったため `logs/jms_note.txt` にメモを残した。`/20/adm/eht/sendClaim` 等での JMS 証跡取得は別 RUN_ID で継続する。
- Flyway/seed 実行ログは `artifacts/parity-manual/db/20251110TnewZ/{flyway_{legacy,modern},seed_{legacy,modern}}.log` に保存し、`flyway_schema_history` が Legacy/Modernized とも 0225 まで到達したことを `psql` で確認済み。

## 付録A. RUN_ID トラッキング（取得済み / 再取得予定 / 未取得）

### A.1 取得済みケース

| シナリオ | 最新 RUN_ID | 証跡 | 備考 |
| --- | --- | --- | --- |
| `trace_http_200` (`GET /serverinfo/jamri`) | 20251110T002045Z | `artifacts/parity-manual/TRACEID_JMS/20251110T002045Z/trace_http_200/` | Legacy/Modernized とも 200 応答。Modernized は `traceId=trace-http-200` が INFO ログへ出力される。 |
| `trace_http_400` (`GET /dolphin/activity/2025,04`) | 20251110T002045Z | `artifacts/parity-manual/TRACEID_JMS/20251110T002045Z/trace_http_400/` | Legacy=500 / Modern=400 だが HTTP/headers/meta を採取済み。 |
| `trace_http_500` (`GET /karte/pid/INVALID,%5Bdate%5D`) | 20251110T002045Z | `artifacts/parity-manual/TRACEID_JMS/20251110T002045Z/trace_http_500/` | Legacy=200 / Modern=400。`TRACE_PROPAGATION_CHECK.md` §7 に差分理由を記録済み。 |
| `PatientServiceBean` JPQL | 20251110T122417Z | `artifacts/parity-manual/JPQL/20251110T122417Z/PatientServiceBean/` | Legacy=200 / Modern=500。JPQL は一致するが `remoteUser=anonymous` で SessionOperation が 500。監査ログは空。 |
| `KarteServiceBean` JPQL | 20251110T122417Z | `artifacts/parity-manual/JPQL/20251110T122417Z/KarteServiceBean/` | Legacy=200（空 JSON） / Modern=400。`KarteBeanConverter` が null を処理できない。 |
| `ScheduleServiceBean` JPQL | 20251110T122417Z | `artifacts/parity-manual/JPQL/20251110T122417Z/ScheduleServiceBean/` | Legacy=200 / Modern=200 だが `{\"list\":null}`。`remoteUser` 未解決の証跡と Hibernate SQL を保存。 |
| `AppoServiceBean` JPQL | 20251110T122417Z | `artifacts/parity-manual/JPQL/20251110T122417Z/AppoServiceBean/` | Legacy/Modern とも 200 (`response=1`)。毎回 reseed して削除件数を合わせた。監査ログは未取得。 |
| `StampServiceBean` (`PUT /stamp/tree`) | 20251111TstampfixZ3 | `artifacts/parity-manual/stamp/20251111TstampfixZ3/` | Legacy/Modern=200。`logs/d_audit_event_stamp_{legacy,modern}.tsv` に TraceId=`parity-stamp-20251111TstampfixZ3` が揃い、`logs/jms_dolphinQueue_read-resource*.txt` は `messages-added=4L`, `message-count=0L` を維持。GET `/stamp/tree/9001` も 200/200（`d_subscribed_tree` 追加で解消）。 |
| `NLabServiceBean` (`GET /lab/module/WEB1001,0,5`) | 20251112TlabReportZ1 | `artifacts/parity-manual/lab/20251112TlabReportZ1/` | Legacy/Modern=200。Modern は `LAB_TEST_READ` が `logs/d_audit_event_lab_modern.tsv` に記録され、`logs/jms_dolphinQueue_read-resource.{before,after}.txt` で `messages-added=10L→12L` を確認。Legacy は Audit/JMS が未記録（`REST_UNAUTHORIZED_GUARD` のみ）。 |

### A.2 再取得予定ケース

| シナリオ | 既存 RUN_ID | 不足内容 | 次アクション |
| --- | --- | --- | --- |
| `trace_http_401` (`GET /touch/user/...` パスワード欠落) | 20251109T060930Z, 20251110T002045Z | `TouchRequestContextExtractor` が 500 を返し 401 にならない。 | Touch 用ヘッダーを `TRACE_PROPAGATION_CHECK.md` に沿って修正し、`@SessionOperation` 付与後に再取得。 |
| `trace-schedule-jpql` (`GET /schedule/pvt/2025-11-09`) | 20251110T122417Z, 20251110T123655Z, 20251110T234440Z, **20251111T070532Z** | RUN_ID=`20251111T070532Z` では Legacy/Modern=200 かつ `list` に `架空 花子` 1 件が復帰し、HTTP/メタは `artifacts/parity-manual/schedule/20251111T070532Z/` に保存済み。ただし `d_audit_event` は `SYSTEM_ACTIVITY_SUMMARY` のみ、`logs/jms_note.txt` もヒットなし。 | `TRACEID_JMS/<next RUN>/trace-schedule-jpql/` へ Audit/JMS 証跡を追加し、`d_audit_event` へ TraceId を残す修正を優先。 |
| `trace-appo-jpql` (`PUT /appo`) | 20251110T122417Z, 20251110T123655Z, 20251110T234440Z, **20251111T070532Z** | reseed（`tmp/reseed_appo.sql`）後に Legacy/Modern=200（削除件数=1）で再取得し `artifacts/parity-manual/appo/20251111T070532Z/` に保存。Audit/JMS は今回も空で `d_audit_event_{legacy,modern}.txt` は SYSTEM_ACTIVITY のみ。 | `artifacts/parity-manual/appo/20251111T070532Z/` の HTTP/ログ形式を維持しつつ、SessionOperation から Audit/JMS を発火させて再取得する。 |
| `PatientServiceBean` JPQL | 20251110T122417Z | Modern が 500 (`SessionServiceException`) のまま / 監査ログ無し。 | `remoteUser` を Elytron/JACC で復元し、`d_audit_event` に TraceId が残る状態で再取得。 |
| `KarteServiceBean` JPQL | 20251110T122417Z | Modern 400（`KarteBeanConverter` が null 非対応）、監査ログ無し。 | `KarteBeanConverter` null-safe 化 + `chart_summary` seed 追加後に再取得し、`d_audit_event` を同梱。 |
| `ScheduleServiceBean` JPQL | 20251110T122417Z | 監査ログなし・`remoteUser=anonymous`。 | 認証ヘッダー復元＆ `docker compose exec db* psql` で `d_audit_event` を保存。 |
| `AppoServiceBean` JPQL | 20251110T122417Z | reseed 前提が必要、監査未採取。 | reseed 手順を自動化し、`d_audit_event` / JMS を同梱する。 |
| `LetterServiceBean` (`PUT /odletter/letter`) | 20251110T123655Z, 20251110T234440Z, 20251110TnewZ, **20251111T070532Z / 20251111TrestfixZ** | RUN_ID=`20251111TrestfixZ` で Legacy=200（戻り値 18）/Modern=200（戻り値 -38）まで回復し `artifacts/parity-manual/letter/20251111TrestfixZ/` に HTTP/ログを保存。`logs/d_audit_event_letter.tsv` / `logs/jms_dolphinQueue_read-resource.txt` は TraceId 行 0 件で JMS も `message-count=0L`。 | `sendClaim` 認証/JMS ルートを修正し、`artifacts/parity-manual/TRACEID_JMS/<next>` で `EHT_CLAIM_SEND` が記録されるまで再取得。Audit 可視化後に Appendix を「取得済み」へ移動。 |
| `/20/adm/factor2/totp/registration` | 20251118Tfactor2ParityZ2 | Legacy=404（WildFly10 では Factor2 REST を公開していない既知事象）/Modern=200。`artifacts/parity-manual/factor2/20251118Tfactor2ParityZ2/` に HTTP/headers/meta, `logs/send_parallel_request.log`, `logs/jms_dolphinQueue_read-resource{,_legacy}.{before,after}.txt`（Modern `messages-added`=23L→26L）, `logs/d_audit_event_factor2_{modern,legacy}.tsv` を保存し、`d_factor2_credential_modern.csv` で TOTP レコード生成を確認。レスポンスの `secret`/`provisioningUri` は README で `***masked***`。 | SessionAuditDispatcher 経由で監査/JMS を取得するフローを Appendix A.6 に記録済み。Legacy 404 は README へ理由を明記し、Modern 側のみ 200 を維持。 |
| `/20/adm/factor2/fido2/{registration,assertion}/options` | 20251118Tfactor2ParityZ2 | Legacy=404 / Modern=200。`logs/d_audit_event_factor2_modern.tsv` に `FIDO2_{REGISTER,ASSERT}_INIT` が 1 行ずつ追加され、JMS は TOTP と合算で +3 件 enqueue。`logs/d_factor2_challenge_modern.csv` で registration/assertion チャレンジが生成されたことを確認。 | Appendix A.6 の FIDO 手順を参照し、`tmp/factor2/fido_{registration,assertion}_options_payload.json` を使って helper コンテナから再取得する。 |
| `/20/adm/eht/sendClaim` / `/karte/diagnosis/claim` / `/mml/send` | 20251112TmessagingDiagZ1 | Legacy=404 / Modern=400（Claim）/406（Diagnosis）/500（MML）。`artifacts/parity-manual/messaging/20251112TmessagingDiagZ1/logs/modern_server.log` に `RESTEASY-JACKSON000100`（`IDocInfo.admFlag` 二重定義）と `MmlResource.sendMmlPayload: Failed to dispatch MML payload` が記録され、Audit/JMS は 0。 | `open.dolphin.adm20.converter.{IDocument,IDocInfo,ISendPackage}` を再生成して重複フィールドを除去し、WAR/Velocity テンプレを再ビルドした後に Appendix A.6 の CLI 手順を再実施。 |
| `NLabServiceBean` (`GET /lab/module/{pid}`) | 20251110T123655Z, 20251110T234440Z, 20251110TnewZ, **20251111T070532Z / 20251111TrestfixZ** | RUN_ID=`20251111TrestfixZ` で Legacy/Modern=200 かつ `response.json={"list":[]}` を確認し、`artifacts/parity-manual/lab/20251111TrestfixZ/` に HTTP/ログを保管。Audit/JMS は Letter と同じく 0 件。 | AuditTrail/JMS が TraceId を残すよう Service 層の SessionOperation を拡張する。完了後は `logs/d_audit_event_lab.tsv` に TraceId 行が追加されたことを確認。 |
| `JPQL リトライ一式` | 20251110T034844Z | `curl: (7)` で全ケース失敗。HTTP/SQL 未生成。 | Docker Desktop 復旧後に同 4 ケースを再実行し、`artifacts/parity-manual/JPQL/<new RUN_ID>/` へ差し替え。 |
| Trace Harness 再試行 | 20251110T035118Z, 20251110T070638Z | `status_code=000`（`curl (6/7)`）。Docker 不在。 | Mac で Docker を起動し、`trace_http_{200,400,401,500}`, `trace-{schedule,appo}-jpql` を撮り直す。 |

- **PK 揃え済み→再取得待ち**: 2025-11-11 06:23Z (`artifacts/parity-manual/db/20251111T062323Z/karte_id_check.txt`) で Legacy/Modernized 双方の `d_karte` を採取し、`ops/db/local-baseline/local_synthetic_seed.sql` へ `WEB1001` の `d_karte.id=10` 強制ロジックを追加。Modern DB は `docker exec opendolphin-postgres-modernized psql -c "INSERT id=10"`→`DELETE id=6` で入れ替え、`SELECT setval('opendolphin.hibernate_sequence',10,true);` を実行済み。Letter/Lab/Stamp parity は PK ブロッカーが解消されたため、Docker 再デプロイと RUN_ID `20251110TnewZ` の再取得を待つ。

### A.3 未取得ケース

| シナリオ | 期待証跡 | 次アクション |
| --- | --- | --- |
| _該当なし_ | - | - |

### A.4 StampTree 作業ログ / payload 履歴

| RUN_ID | 作業内容 | 証跡 | 備考 |
| --- | --- | --- | --- |
| 20251111TstampfixZ2 | `tmp/parity-letter/stamp_tree_payload.json` を GET 結果へ同期（versionNumber=4）し、Legacy 側だけ先に PUT 200 + Audit を確認。 | `tmp/parity-letter/stamp_tree_payload.json`, `artifacts/parity-manual/stamp/20251111TstampfixZ2/{stamp_tree_user9001,PUT_stamp_tree}/` | Modern は `d_subscribed_tree` 欠如により GET 500 のまま。payload diff（`git diff`) で version/treeBytes のみ更新されていることを確認。 |
| 20251111TstampfixZ3 | `ops/db/local-baseline/stamp_tree_oid_cast.sql` を Legacy/Modern 両 DB に適用し、Modern DB に `d_subscribed_tree` を新設後、payload を versionNumber=11 で再生成→PUT 200 / Audit/JMS 200 を取得。 | `artifacts/parity-manual/stamp/20251111TstampfixZ3/logs/d_stamp_tree_cast_migration.txt`, `artifacts/parity-manual/stamp/20251111TstampfixZ3/logs/d_subscribed_tree_migration.txt`, `artifacts/parity-manual/stamp/20251111TstampfixZ3/stamp_tree_user9001/{legacy,modern}/response.json` | `artifacts/parity-manual/stamp/20251111TstampfixZ3/logs/jms_dolphinQueue_read-resource{,_legacy}.txt` に `messages-added=4L`（Modern）/`0L`（Legacy）を記録し、Legacy JMS が message-count=0L である既知事象として Runbook §4.1 へリンク。 |

### A.5 StampTree GET variations 実行結果（RUN_ID=`20251113TstampPublicPlanZ1` / `20251113TstampSharedPlanZ1` / `20251113TstampPublishedPlanZ1`）

helper コンテナ（`mcr.microsoft.com/devcontainers/base:jammy`, `--network legacy-vs-modern_default`）で `./ops/tools/send_parallel_request.sh --profile modernized-dev GET /stamp/tree/9001/<variation>` を実行。Legacy/Modern とも 200 を返し、`PublishedTreeList`・Audit・JMS を `artifacts/parity-manual/stamp/20251113Tstamp<Variation>PlanZ1/` に集約した。

| Variation | RUN_ID | HTTP Legacy / Modern | Audit / JMS 所見 | 証跡 |
| --- | --- | --- | --- | --- |
| `GET /stamp/tree/9001/public` | 20251113TstampPublicPlanZ1 | `200 / 200`（facility=9001 + global の 2 件） | `logs/d_audit_event_stamp_public_{legacy,modern}.tsv` に `STAMP_TREE_PUBLIC_GET`（`facilityId=9001`, `resultCount=2`, `traceId=parity-stamp-tree-public-20251113TstampPublicPlanZ1`）。JMS は read-only（`messages-added` 変化なし）。 | `artifacts/parity-manual/stamp/20251113TstampPublicPlanZ1/` |
| `GET /stamp/tree/9001/shared` | 20251113TstampSharedPlanZ1 | `200 / 200`（共有スタンプ 1 件） | `d_audit_event_stamp_shared_{legacy,modern}.tsv` に `resultCount=1` が追加。JMS before/after 差分なし。 | `artifacts/parity-manual/stamp/20251113TstampSharedPlanZ1/` |
| `GET /stamp/tree/9001/published` | 20251113TstampPublishedPlanZ1 | `200 / 200`（local + global = 3 件） | `d_audit_event_stamp_published_{legacy,modern}.tsv` に `STAMP_TREE_PUBLISHED_GET` を記録。JMS は read-only。 | `artifacts/parity-manual/stamp/20251113TstampPublishedPlanZ1/` |

> **facility ミスマッチ検証**: RUN_ID=`20251113TstampPublicPlanZ4` で `GET /stamp/tree/9002/public` を実行したところ、Legacy/Modern とも `403 Forbidden`。WARN ログは `artifacts/parity-manual/stamp/20251113TstampPublicPlanZ4/logs/{legacy,modern}_warn.log` に保存し、`reason=facility_mismatch`, `facilityId=9002`, `remoteUser=9001:doctor1` を確認。

##### Appendix A.5 追補: Published/Subscribed seed 投入手順

1. Legacy/Modern 双方の Postgres に `ops/db/local-baseline/stamp_public_seed.sql` を流す。スクリプト内で facility=`9001` / user=`9001:doctor1` / `d_roles` を `NOT EXISTS` で補完した上で、facility=9001/9002/`global` の `d_published_tree` と相互 `d_subscribed_tree` を生成する。
   ```bash
   docker exec -i -e PGPASSWORD=opendolphin opendolphin-postgres \
     psql -U opendolphin -d opendolphin \
     -f /workspace/ops/db/local-baseline/stamp_public_seed.sql
   docker exec -i -e PGPASSWORD=opendolphin opendolphin-postgres-modernized \
     psql -U opendolphin -d opendolphin_modern \
     -f /workspace/ops/db/local-baseline/stamp_public_seed.sql
   ```
2. `SELECT publishType, COUNT(*) FROM d_published_tree WHERE publishType IN ('9001','9002','global') GROUP BY publishType;` と `SELECT treeId, COUNT(*) FROM d_subscribed_tree WHERE treeId IN (65001,65002) GROUP BY treeId;` を実行し、少なくとも各 1 行が入ったことを確認する。`d_subscribed_tree` が無い DB では `CREATE TABLE`（Appendix A.4 で実施済み）を先に適用する。
3. seed 適用結果を `artifacts/parity-manual/stamp/20251113TstampPublicPlanZ1/logs/` に `seed_stamp_public_{legacy,modern}.log` という名前で保存し、公開系 GET 証跡と同じ RUN_ID でまとめる。`DOC_STATUS.md` の該当行に seed 反映日を記載して棚卸し対象から外さないようにする。

上記 seed が入っていない場合は `/stamp/tree/{facility}/{public|shared|published}` が 200 を返せないため、RUN_ID=`20251113TstampPublicPlanZ1` 以降の証跡採取は無効扱いとする。

> **2025-11-12 更新 (RUN_ID=`20251113TstampPublicPlanZ1`)**  
> - Legacy/Modern 双方で `docker exec -i ... psql -U opendolphin -d {opendolphin|opendolphin_modern} < ops/db/local-baseline/stamp_public_seed.sql` を実行し、`seed_stamp_public_{legacy,modern}.log` に結果を保存。Modern 側には `d_published_tree` が存在しなかったため、同スクリプトで DDL（PK/FK/index）を再適用してから seed した。
> - ヘッダー: `tmp/parity-headers/stamp_tree_{public,shared,published}_20251113TstampPublicPlanZ1.headers`（`userName=9001:doctor1`, `facilityId=9001`, `X-Trace-Id=parity-stamp-tree-<variation>-20251113Tstamp<Variation>PlanZ1`）。`TRACE_RUN_ID=20251113Tstamp<Variation>PlanZ1` / `PARITY_OUTPUT_DIR=artifacts/parity-manual/stamp/20251113Tstamp<Variation>PlanZ1` を Appendix A.4（TRACEID_JMS_RUNBOOK）にも同期済み。

`docs/web-client/architecture/WEB_CLIENT_REQUIREMENTS.md` §5.4「公開/共有タブ運用要件」に UI 前提を集約し、以下の比較表で UI 差し替え案 / REST 追加案の影響を整理する。

#### UI差し替え vs REST追加 比較（Appendix A.5 リンク）

| 観点 | UI差し替え（選択肢A） | REST追加（選択肢B） | サーバー/運用ノート |
| --- | --- | --- | --- |
| 施設切替 | `Stamp管理センター` に ADMIN 限定の施設セレクタを実装し、`GET /stamp/published/tree` 応答を UI で施設別にフィルタリング。`PublishedTreeList` キャッシュを facilityId キーで保持し、切替毎にリロードを強制。 | `GET /stamp/tree/{facility}/{public|published}` を追加し、facilityId をサーバーで評価。UI は facilityId を URL パラメータ化するだけで済み、レスポンスは単一施設分。 | どちらの案でも TraceId は `parity-stamp-tree-<visibility>-<RUN_ID>` を再利用し、Appendix A.3 Runbook の証跡採取を踏襲。 |
| ADMIN 権限 | UI レイヤーで ADMIN 以外に施設セレクタ／公開操作を表示しない。購読ボタンは常に有効で、非 ADMIN でもローカル施設に限定。 | `StampResource` で `@RolesAllowed("ADMIN")` を活用し、facility と remoteUser の不一致時に 403 を返す。UI は表示制御のみ行い、通信エラーを管理者権限不足として表示。 | 認可失敗は `AuditTrailService` に `result=forbidden` を記録する必要があり、`TRACEID_JMS_RUNBOOK.md` §4 へ手順を追記する。 |
| 購読状態（共有タブ） | UI が `PUT /stamp/subscribed/tree` / `DELETE /stamp/subscribed/tree/{ids}` 応答の ID リストをキャッシュし、`GET /stamp/published/tree` 結果に `subscriptionState` を合成。`pending` 状態はクライアントのみで管理。 | `GET /stamp/tree/{facility}/shared` もしくは `GET /stamp/subscribed/tree` を追加し、`SubscribedTreeModel` で購読状態を返却。UI はレスポンスの `subscribedTreeIds` をそのまま表示し、`pending` なしで済む。 | DAO へ `getSharedTrees(fid)` を追加し、`d_subscribed_tree` から直接読み取る。監査は `STAMP_TREE_SHARED_GET` を新設。 |
| 証跡・ドキュメント | UI 要件とキャッシュ挙動を `docs/web-client/architecture/WEB_CLIENT_REQUIREMENTS.md` と `docs/web-client/ux/KARTE_SCREEN_LAYOUT_GUIDE.md`（更新予定）へ追記。 | REST 実装が完了したら `domain-transaction-parity.md` Appendix A.5、`TRACEID_JMS_RUNBOOK.md`、`patches/stamp_get_public_plan.md` の RUN_ID テンプレを再生成。 | どちらの案でも `PHASE2_PROGRESS.md` backlog にスケジュールと担当を記載し、DOC_STATUS から両ファイルを参照する。 |

#### Legacy 仕様 vs Modern 実装（現状 404 差分）

| Variation | Legacy 仕様（URL / 認可 / レスポンス） | Modern 実装の現状 | 差分と次ステップ |
| --- | --- | --- | --- |
| `public` | `GET /stamp/published/tree` が施設 ID ごとの公開スタンプを `PublishedTreeList` で返却（`docs/server/LEGACY_REST_API_INVENTORY.md` §5, `docs/web-client/architecture/WEB_CLIENT_REQUIREMENTS.md` §14.6）。アクセス時は `LogFilter` が `userName` / `password` / `facilityId` ヘッダーを検証し、Principal が取れない場合のみヘッダーフォールバックを使用（`docs/server-modernization/phase2/notes/security-elytron-migration.md` §1）。 | Legacy/Modern とも `/stamp/tree/{facility}/public` を実装済みで、`RUN_ID=20251113TstampPublicPlanZ1` では 200 + Audit/JMS を記録。facility ミスマッチ時は 403 + WARN（`RUN_ID=20251113TstampPublicPlanZ4`）。 | Web クライアントは facility 切替時に `/stamp/tree/{facility}/public` を呼び出し、403 を UI で通知。`/stamp/published/tree` はレガシー用としてしばらく維持。 |
| `shared` | 共有リストは購読テーブル（`SubscribedTreeModel`）を `PUT /stamp/subscribed/tree` / `DELETE /stamp/subscribed/tree/{ids}` で更新し、UI が `PublishedTreeList` と合成していた。 | `/stamp/tree/{facility}/shared` を実装し、`RUN_ID=20251113TstampSharedPlanZ1` で 200 / Audit 記録を確認。`StampServiceBean#getSharedTrees(fid)` が `publishType=fid` を直接参照する。 | UI は `/stamp/tree/{facility}/shared` の `resultCount` をそのまま描画し、購読状態の合成・pending 管理を削減。 |
| `published` | Legacy UI は `GET /stamp/published/tree` を再利用し、facility 公開分と全体公開分を `PublishedTreeList` 内で判別する。 | `/stamp/tree/{facility}/published` を追加し、`RUN_ID=20251113TstampPublishedPlanZ1` で 200 / Audit を取得。`getFacilityPublishedTrees(fid)` が shared + public をマージ。 | UI は facility 切替時に `/stamp/tree/{facility}/published` を呼び、`/stamp/published/tree` はレガシー備えとして保持。 |

### A.6 Legacy JMS 設定参照ポイント（StampSenderMDB 再起動前チェック）

| ファイル | 参照/取得手順 | 主な確認項目 | 再起動後記録項目 |
| --- | --- | --- | --- |
| `server/standalone-full.xml` | `docker compose -f docker-compose.yml -f docker-compose.modernized.dev.yml cp opendolphin-server:/opt/jboss/wildfly/standalone/configuration/standalone-full.xml artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/standalone-full_after.xml` でローカルにコピーし、`rg -n 'messaging-activemq\|dolphinQueue\|pooled-connection-factory' artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/standalone-full_after.xml` で抜粋。 | `jms-queue name="dolphinQueue"` の `entries/jndi-name`, `consumer-window-size`, `durable`、および `messaging-activemq` セクションの connection-factory 設定。 | `diff -u artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/standalone-full_before.xml artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/standalone-full_after.xml` の出力を `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/standalone-full.diff` に保存し、差分ゼロなら `OK` と記録。 |
| `server/src/main/resources/META-INF/ejb-jar.xml` | `docker compose cp opendolphin-server:/opt/jboss/wildfly/standalone/deployments/opendolphin.war/WEB-INF/ejb-jar.xml artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/ejb-jar_after.xml` を取得し、`rg -n 'StampSenderMDB\|activation-config-property' artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/ejb-jar_after.xml` でブロック確認。 | `StampSenderMDB` の `activation-config-property`（`destinationLookup`, `acknowledgeMode`, `maxSession` 等）が `standalone-full.xml` の JMS 定義と整合しているか。 | `diff -u artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/ejb-jar_before.xml artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/config/ejb-jar_after.xml` を `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/ejb-jar.diff` に残し、差分に activation-config の変化がないことをメモ。 |
| `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/legacy_mdb_restart.log` | `TRACEID_JMS_RUNBOOK.md` §5.7 のテンプレを用い、helper 経由で stop/start/read-resource を `tee` しながら保存。 | `/deployment=opendolphin.war/...=StampSenderMDB:{stop,start}` の成功、WARN/ERROR の有無。 | `read-resource(include-runtime=true)` 出力に含まれる `messages-added`, `message-count`, `consumer-count`, `consumer-created-count` を操作ごとにコメント追記し、`再起動後 5 分以内` の観測値として表に記載。 |
| `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/{before,after}_jms_dolphinQueue_read-resource(_legacy).txt` | `LEGACY_MODERNIZED_CAPTURE_RUNBOOK.md §3.4` の helper コンテナ手順で採取。 | Legacy/Modern の JMS queue runtime 値が期待どおりか（Legacy: `messages-added=0L`, Modern: >0 → 0）。 | 各ファイル先頭に `messages-added`, `message-count`, `consumer-count`, `delivering-count` を手動で追記し、`diff -u` の結果を `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/jms_dolphinQueue_read-resource.diff` へ保存。 |
| `artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/server.log` | `docker compose cp opendolphin-server:/opt/jboss/wildfly/standalone/log/server.log artifacts/parity-manual/TRACEID_JMS/<RUN_ID>/logs/server.log` で取得。 | 再起動時刻前後の `StampSenderMDB` ログ、`HornetQClientSessionFactory` など JMS 接続再確立メッセージ。 | `StampSenderMDB Stopping` / `Starting` の UTC タイムスタンプを抽出し、`legacy_mdb_restart.log` の stop/start コマンド時刻との差を <60 秒に抑えられているかをコメント。 |

> **メモ:** 上記ファイルは StampSenderMDB 再起動や JMS 設定変更を検討する前提情報として Appendix に集約。`PHASE2_PROGRESS.md` ブロッカー節と `SERVER_MODERNIZED_DEBUG_CHECKLIST.md` フェーズ4-2 からも本表を参照する。
