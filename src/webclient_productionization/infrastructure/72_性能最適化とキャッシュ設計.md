# 性能最適化とキャッシュ設計

- RUN_ID: 20251228T205654Z
- 期間: 2026-02-12 09:00 - 2026-02-13 21:00
- ステータス: completed
- 進捗: 100
- YAML ID: src/webclient_productionization/infrastructure/72_性能最適化とキャッシュ設計.md
- 参照ガント: .kamui/apps/webclient/webclient-productionization-plan-20251226.yaml

## 進捗記入ルール
- 担当者は作業開始時に RUN_ID/期間/ステータス/進捗 を更新する。
- 実施ログに日付・作業内容・成果物（コミット/証跡パス）・検証結果・残課題を追記する。
- 進捗更新時は docs/DEVELOPMENT_STATUS.md の懸念点有無も確認し、必要ならここに反映する。

## 進捗メモ（担当者が更新）
- 担当者: Codex CLI
- 更新日: 2025-12-28
- 根拠: `web-client/src` の React Query 設定と `DocumentTimeline` のウィンドウ化実装を確認し、ORCA-08 の TTL/ETag 方針と整合するキャッシュ方針を整理した。
- 次アクション: 実運用の P95/P99 を計測し、画面単位で staleTime/GC とウィンドウサイズを再調整する。
- 懸念点: docs/DEVELOPMENT_STATUS.md に記載の懸念点と本項目は直接連動せず、追加の更新は不要と判断。


## 目的
- 大量データ表示時の描画負荷を抑え、診療中の UI ブロッキングを防止する。
- データ種別ごとのキャッシュ期限と再取得条件を明確化し、UX と監査メタ (`cacheHit`/`dataSourceTransition`) の整合を保つ。

## 現状サマリ（既存実装の把握）
- `web-client/src/main.tsx` の React Query 既定値は `staleTime=60s` / `retry=1`。
- Reception/Charts では `claim` が `staleTime=90s` + `refetchInterval=90s`、予約・キュー系は `refetchOnWindowFocus=false` で意図的に抑制。
- Charts の `DocumentTimeline` は windowing を実装済み（表示件数のスライスと移動）。
- `cacheHit`/`missingMaster`/`dataSourceTransition` は UI バナー/監査ログに連携済み。

## 方針（レンダリング最適化）
- 大量リストは **windowing/virtualization** を標準方針とし、表示件数の上限・中心移動の UI を統一する。
- 検索・絞り込み・並び替えは `useMemo` と `useDeferredValue` で分離し、入力イベントを `startTransition` で低優先度化する。
- 集計や並び替えの重い処理は `requestIdleCallback` / `setTimeout(0)` で後回しにし、UI を先に描画する。
- 画像/印刷用コンテンツは遅延生成し、診療中のメインスレッドを塞がない。

## 方針（キャッシュ期限と再取得条件）
### データ種別ごとの基本方針
- **短期更新データ**（受付/予約/ORCA キュー）: 60〜90 秒の短い `staleTime` と明示的な `refetchInterval`。画面フォーカスでは再取得しない。
- **中期更新データ**（患者一覧/患者基本情報）: `staleTime` は 2〜5 分、操作完了時に `invalidateQueries` で強制再取得。
- **長期更新データ**（ORCA マスタ）: サーバーの ETag/Cache-Control を優先し、UI は `cacheHit` と `dataSourceTransition` をそのまま表示する。
- **設定系データ**（Administration の配信設定/権限）: 画面起動時に取得し、更新操作後のみ明示的に無効化する。

### 再取得のトリガ
- 手動更新ボタン・キュー操作・保存完了後の `invalidateQueries` を主トリガにする。
- `admin:broadcast` の通知を受けた場合のみ関連クエリを再取得する。
- 画面フォーカスでの再取得はデフォルト無効（診療中の UI ブロッキング抑制）。

## 非同期制御（UI ブロッキング抑止）
- 画面遷移と大規模データ取得は分離し、遷移後に非同期で詳細を差し込む。
- React Query の `keepPreviousData` と skeleton 表示で、空白描画を避ける。
- 同期的に 1,000 件以上を再描画する処理は `startTransition` に寄せ、ユーザー入力を優先する。

## 並列化意図（依存変更の理由）
- セキュリティ/ログマスキング（71）と独立して進められるため、環境設定（70）完了後に並列着手する。
- キャッシュ/性能方針は環境変数やビルド配信前提（70）を参照するため、70 の完了を前提とする。

## 受け入れ基準 / Done
- 大量データ表示（目安: 1,000 件以上）でスクロール/フィルタ操作が 100ms 以内に反応し、フリーズが発生しない。
- データ種別ごとの `staleTime`/再取得トリガを文書化し、UI トーン (`cacheHit`/`dataSourceTransition`) と矛盾しない。
- 画面フォーカスでの不要な再取得がなく、診療中の画面操作で UI ブロッキングが発生しない。

## 実施ログ
- 2025-12-27: 依存変更の理由を追記（RUN_ID: 20251227T221802Z）。
- 2025-12-28: 既存実装のキャッシュ設定とウィンドウ化を棚卸しし、性能/キャッシュ方針と再取得条件を整理（RUN_ID: 20251228T205654Z）。
