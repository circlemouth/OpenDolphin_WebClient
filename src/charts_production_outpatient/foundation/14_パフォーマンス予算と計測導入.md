# 14 パフォーマンス予算と計測導入（webclient charts production outpatient plan）

- RUN_ID: `20251217T060433Z`
- 期間: 2025-12-30 09:00 〜 2026-01-01 09:00 (JST) / 優先度: medium / 緊急度: medium / エージェント: gemini cli
- YAML ID: `src/charts_production_outpatient/foundation/14_パフォーマンス予算と計測導入.md`
- 参照: [03 モダナイズ外来 API 契約テーブル確定](../03_モダナイズ外来API契約テーブル確定.md)、[10 セッションと権限ガード整理](10_セッションと権限ガード整理.md)、[11 監査ログauditEvent統一](11_監査ログauditEvent統一.md)、[12 エラーハンドリングとリトライ規約](12_エラーハンドリングとリトライ規約.md)、[13 データ取得レイヤの統一_fetchWithResolver](13_データ取得レイヤの統一_fetchWithResolver.md)、`docs/web-client/ux/charts-claim-ui-policy.md`、`docs/web-client/architecture/web-client-api-mapping.md`
- 証跡ログ: `docs/web-client/planning/phase2/logs/20251217T060433Z-charts-performance-budget.md`

---

## 0. 結論（決めたこと）
- Charts の体感性能を **3 つの SLI** に固定: ①初回オープン体感時間、②同一セッション内の患者切替時間、③タイムライン自動/手動更新時間。各 SLI を P95 ベースの **パフォーマンス予算** と **警告/違反の 2 段階しきい値** で管理する。
- ローディング表現は **共通スケルトン + 段階表示** に統一し、Waiting 状態でも「操作可能な領域」と「未確定領域」を明示する。スピナー単体は禁止。スケルトンには `data-loading-scope` を付与し、ToneBanner/ガードと共存させる。
- 計測は `fetchWithResolver` と UI マーク（performance.mark）を組み合わせ、**telemetry funnel** + **auditEvent.details.performance** に秒単位で送出する。計測キーは runId/traceId/patientIdHash/dataSourceTransition/cacheHit/missingMaster を必須とし、11 章の監査キーと揃える。

## 1. パフォーマンス予算（P95 指標）
| フロー | SLI の定義 | 目標 (P95) | 警告ライン | 違反ライン | 測定起点 → 終点 |
| --- | --- | --- | --- | --- | --- |
| 初回オープン | Charts ルート遷移完了→ヘッダー + Timeline/Panels スケルトン描画完了 | ≤ 2.0s | > 2.0s | ≥ 2.5s | `charts:init_start` → `charts:first_paint` |
| 患者切替 | PatientsTab から患者選択→DocumentTimeline の最新エントリ描画完了（スケルトン可） | ≤ 1.0s | > 1.0s | ≥ 1.3s | `charts:patient_switch_start` → `charts:patient_ready` |
| タイムライン更新 | 「再取得」/自動ポーリング開始→DocumentTimeline が最新 runId を表示 | ≤ 1.2s | > 1.2s | ≥ 1.6s | `charts:timeline_refresh_start` → `charts:timeline_ready` |

- しきい値判定は `performance.now()` を ms 精度で計測し、P95 集計は telemetry 側で実施。P90 もダッシュボード上で補助指標として表示。
- 警告ライン到達時は ToneBanner info（polite）で「遅延しています（runId=…, traceId=…）」を表示、違反ラインで warning/assertive に格上げし 12 章の再取得導線を自動で開く。
- `missingMaster=true` / `fallbackUsed=true` の場合は計測対象外（ガード優先）。`dataSourceTransition='snapshot'` は別カテゴリで集計。

## 2. ローディング表現の統一
- **スケルトン統一**: DocumentTimeline/OrcaSummary/PatientsTab/OrderConsole は `SkeletonPanel`（tone: neutral, `data-loading-scope=<panel>`）を使用。高さ・ブロック数はコンポーネントごとに固定し、点滅/無限スピナーは禁止。
- **段階表示**: 200ms 以内にヘッダー + タブ列を描画 → 800ms 以内に左カラム（Timeline/PatientsTab）スケルトン表示 → 1200ms 以内に右カラム（OrcaSummary/OrderConsole）スケルトン。表示順は 10 章の権限ガードを満たした領域のみ。
- **操作可能領域の明示**: タイムライン更新中でもアクションバーは活性を維持し、待機中のパネルには `data-state="loading"` + disabled を付与。ボタンには `aria-describedby` でローディング理由を接続。
- **ToneBanner との共存**: ローディング時も ToneBanner を表示し続け、warn/error が優先レイヤー。スケルトンは banner 下に配置。

## 3. 計測・テレメトリ設計
- **マーク/メジャー**
  - `performance.mark('charts:init_start')` をルート遷移直後に、`...:first_paint` を最初のスケルトン描画完了時に設置。
  - 患者切替/再取得は `charts:patient_switch_start|ready`、`charts:timeline_refresh_start|ready` を useQuery の `onSuccess` / `onSettled` で設定。
  - 13 章の `fetchWithResolver` で `meta.fetchedAt` を受け取り、`performance.measure` に利用。
- **telemetryClient.recordOutpatientFunnel**（既存ステージに追加/改名）
  - `charts_perf_init`（durationMs, cacheHit, dataSourceTransition, runId, traceId）
  - `charts_perf_patient_switch`（durationMs, patientIdHash, missingMaster, fallbackUsed, servedFromCache）
  - `charts_perf_timeline_refresh`（durationMs, retryCount, servedFromCache）
- **auditEvent.details.performance**
  - キー: `durationMs`, `fromCache`, `retryCount`, `dataSourceTransition`, `cacheHit`, `missingMaster`, `fallbackUsed`, `runId`, `traceId`。
  - 11 章の監査必須キーと同一の runId/traceId を使い、患者識別子はハッシュ化（`patientIdHash`）。
- **UI 属性**
  - スケルトンに `data-performance-scope`（init/patient_switch/timeline_refresh）、`data-run-id` を付与し Playwright/HAR で抽出可能にする。
  - パフォーマンス警告バナー: `data-perf-warning-level=warn|violation` を追加。12 章の ToneBanner 実装に属性追加で対応。

## 4. 実装タスク（開発向けメモ）
- `web-client/src/features/charts/pages/ChartsPage.tsx`: route entry で `performance.mark('charts:init_start')`、最初のスケルトン描画で `...first_paint`、`recordOutpatientFunnel('charts_perf_init')` を送る。
- `web-client/src/features/charts/hooks/usePatientSwitch.ts`（新設想定）または既存ハンドラ: 切替開始/完了で mark→measure→telemetry。`patientIdHash` を util 化（PII 不保存）。
- `web-client/src/features/charts/api.ts` / `reception/api.ts`: `fetchWithResolver` meta から `servedFromCache/retryCount` を受け取り `auditEvent.details.performance` に注入。
- `web-client/src/components/SkeletonPanel.tsx`（新設または既存拡張）: `data-loading-scope` / `data-performance-scope` / `data-run-id` 属性を実装し、スピナー廃止。
- `web-client/src/features/charts/components/ToneBanner.tsx`（想定）: `data-perf-warning-level` 追加、警告ライン到達時に info→warning へ自動昇格。
- テスト: `tests/e2e/charts-performance.spec.ts` を追加し、MSW ON/OFF で (init/patient_switch/timeline_refresh) の duration を計測。しきい値超過時は CI 失敗とし、HAR に duration を保存。

## 5. 計測/検証フロー
1. **MSW ON（開発）**: runId を固定し、`performance.measure` 値を console + telemetry に送信。P95 集計はローカルエミュレーションで 30 リクエストを回し確認。
2. **MSW OFF + dev proxy**: `VITE_DISABLE_MSW=1 VITE_DEV_PROXY_TARGET=http://localhost:9080/openDolphin/resources` で同じシナリオを実施し、server latency を含めた基準を更新。
3. **Stage/Preview（権限取得後）**: `RUN_ID=20251217T060433Z` を流用し、Playwright で init/patient_switch/timeline_refresh の三計測を CI に記録。結果を `docs/server-modernization/phase2/operations/logs/<RUN_ID>-charts-performance.md` に転記予定。
4. **アラート運用**: 違反ライン超過が 3 回連続した場合、ToneBanner を error→warning に戻すまで `telemetryClient.recordOutpatientFunnel('charts_perf_degraded')` を送信し、12 章の再取得導線を強制表示。

## 6. 未決事項・フォローアップ
- Sentry や外部 APM への送信は現状未連携。telemetryClient の Backend 受け口が決まり次第、`charts_perf_*` イベントの JSON スキーマを `operations/TRACE_PROPAGATION_CHECK.md` に追記する。
- `performance.mark` の polyfill を IE11 互換コードから除外済みか確認が必要（現行バンドルでは問題ない想定）。
- タイムライン以外（OrderConsole 保存、Patients 編集保存）の体感性能指標は本 RUN での対象外。次 RUN で SLI 拡張を検討する。
