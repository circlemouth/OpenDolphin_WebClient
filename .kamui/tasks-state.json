[
  {
    "id": "task-1768178988749-9aea39",
    "name": "対象ファイル: .kamui/apps/webclient-charts-compact-layout-plan-20260111.yaml\n\n36タスクまで完了しているはずだ。残るタスクの必要性について再評価し、不要なタスクは削除、進捗更新、タスクの集約化を行え。とくにsvg作成は不要な可能性があると思われる。",
    "model": "Codex CLI",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "branchName": null,
    "baseBranch": null,
    "worktreePath": null,
    "createWorktree": false,
    "createdAt": "2026-01-12T00:49:48.749Z",
    "updatedAt": "2026-01-12T00:49:48.749Z",
    "requiresTerminal": true,
    "bookmarked": false,
    "aiCompetitionEntry": false,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": null,
    "aiCompetitionGroupName": null,
    "autoEvaluationNotBefore": null,
    "useTmux": false,
    "taskType": null,
    "modelId": null,
    "latestVersion": null,
    "currentVersion": null,
    "installSteps": [],
    "installCommand": null,
    "createdAutomatically": false,
    "dependencies": []
  },
  {
    "id": "task-yaml-1rr1ie-src-webclient-ch",
    "name": "[webclient charts compact layout plan 20260111] 37_ユーティリティ導線統合確認\n期間: 01/13 12:00 - 01/14 12:00 / 優先度: medium / 緊急度: high / エージェント: cursor cli\n\n# 37 ユーティリティ導線統合確認\n\n- ドロワーと既存のショートカット導線が競合しないことを確認する。\n- DockedUtilityPanel の開閉で主要導線が隠れないことを確認する。\n- DockedUtilityPanel の状態遷移（compact/expanded）とフォーカス移動を結合検証する。\n- 診療操作/病名/処方/オーダー/文書の切替が期待通り動作することを確認する。\n\nYAML ID: src/webclient_charts_compact_layout_plan_20260111/integration/37_ユーティリティ導線統合確認.md",
    "model": "Codex CLI",
    "status": "completed",
    "importance": "medium",
    "urgency": "high",
    "branchName": "task/task-yaml-1rr1ie-src-webclient-ch",
    "baseBranch": "main",
    "worktreePath": null,
    "createWorktree": false,
    "createdAt": "2026-01-12T06:09:46.012Z",
    "updatedAt": "2026-01-12T08:56:54.954Z",
    "requiresTerminal": false,
    "bookmarked": false,
    "aiCompetitionEntry": false,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": null,
    "aiCompetitionGroupName": null,
    "autoEvaluationNotBefore": null,
    "useTmux": false,
    "taskType": "yaml-plan",
    "modelId": null,
    "latestVersion": null,
    "currentVersion": null,
    "installSteps": [],
    "installCommand": null,
    "createdAutomatically": false,
    "dependencies": [
      "task-yaml-8nkxbw-src-webclient-ch",
      "task-yaml-1s46k9m-src-webclient-ch"
    ]
  },
  {
    "id": "task-1768217310278-4c12de",
    "name": "CodexCLI1: 【プロンプトA】ORCA連携の既存不具合修正（patientlst2v2 / acsimulatev2 の Trial 500 を潰す）\n\nあなたは、ORCA連携（WebORCA Trial含む）のモダナイズ版Webクライアント実装を修正してください。\n狙いは「HTTP 500 を出さず、ORCA仕様どおりのレスポンス（Api_Result等）を返せる状態」に戻すことです。\n\n■前提（超重要）\n1) WebORCA向けは “APIパスの先頭に /api を付ける” 必要がある。\n   例：/api01rv2/... も /orca11/... も /api21/... も、WebORCAでは /api/ を前に付ける。\n2) 認証はHTTPの基本認証（Basic authentication）。ユーザID/パスワードは ORCA の職員（オペレータ）IDとパスワード。\n   （このプロジェクトでは既に Authorization: Basic ... を送っているので、そのままでOK）\n3) XMLは ORCA が要求する “型付きXML” を送る必要がある。\n   ここで言う型付きXMLとは、各タグに type=\"string\"/\"record\"/\"array\" が付く形式（xml2形式）。\n   配列は *_child を繰り返す形になる。\n\n■現状の問題（事実）\n- patientlst2v2 と acsimulatev2 を Trial に送ると HTTP 500 になる。\n- 現在送っているリクエストは、URLのクエリに class が付いていない。\n- さらに、Bodyが xml2形式（type属性付き）になっていない。\n\n■結論（修正方針）\nHTTP 500 の原因は「(a) class=01 が欠けている」「(b) リクエストXMLがxml2形式ではない」が最有力。\nこの2点をまず確実に直す。加えて、患者番号は数字文字列を使う（\"MOCK-500\" のような文字列は Trial/ORCA側で想定外の可能性が高い）。\n\n------------------------------------------------------------\n【1】patientlst2v2 の修正\n------------------------------------------------------------\n■正しいエンドポイント\n- WebORCA Trial へ送る完全URL例：\n  https://weborca-trial.orca.med.or.jp/api/api01rv2/patientlst2v2?class=01\n\n■HTTPメソッド\n- POST\n\n■ヘッダ\n- 既存どおりでOK：\n  Content-Type: application/xml; charset=UTF-8\n  Accept: application/xml\n  Authorization: Basic <既存のもの>\n\n■正しいBody（xml2形式。最小の形）\n<data>\n  <patientlst2req type=\"record\">\n    <Patient_ID_Information type=\"array\">\n      <Patient_ID_Information_child type=\"record\">\n        <Patient_ID type=\"string\">00012</Patient_ID>\n      </Patient_ID_Information_child>\n      <!-- 複数なら child を増やす（最大100件） -->\n    </Patient_ID_Information>\n  </patientlst2req>\n</data>\n\n■注意\n- “存在しない患者番号” でも、本来はHTTP 500ではなく「氏名に『患者番号がありません』等のメッセージを埋めて返す」仕様。\n  なので 500 が出るのは、ほぼリクエストの作り方の誤り。\n- まずは Trial 内に存在する「数字の患者番号」で試す。\n  （どうしても分からなければ、既に動いている acceptlstv2 等のレスポンスから Patient_ID を拾って再利用する）\n\n------------------------------------------------------------\n【2】acsimulatev2 の修正\n------------------------------------------------------------\n■正しいエンドポイント\n- WebORCA Trial へ送る完全URL例：\n  https://weborca-trial.orca.med.or.jp/api/api01rv2/acsimulatev2?class=01\n\n■HTTPメソッド\n- POST\n\n■ヘッダ\n- 既存どおりでOK：\n  Content-Type: application/xml; charset=UTF-8\n  Accept: application/xml\n  Authorization: Basic <既存のもの>\n\n■正しいBody（xml2形式。最小構成の考え方）\n- 送るべき最低限の“形”はこれ（type属性＋array/childを必ず守る）\n- 保険情報は「送らない」ことも理屈上は可能だが、Trialでは前回受診などに依存して失敗しやすい。\n  まずは保険情報も一緒に送る（patientlst2v2等のレスポンスから保険・公費情報を埋める）方が成功率が高い。\n\n<data>\n  <acsimulatereq type=\"record\">\n    <Patient_ID type=\"string\">03999</Patient_ID>\n    <Perform_Date type=\"string\">2026-01-11</Perform_Date>\n    <Perform_Time type=\"string\"></Perform_Time>\n    <Time_Class type=\"string\">0</Time_Class>\n\n    <Diagnosis_Information type=\"record\">\n      <Department_Code type=\"string\">01</Department_Code>\n\n      <!-- まずはこれを送る：保険・公費情報（record/array構造を守る）\n           値は patientlst2v2 / patientlst6v2 等の結果から埋める -->\n      <HealthInsurance_Information type=\"record\">\n        <InsuranceProvider_Class type=\"string\">060</InsuranceProvider_Class>\n        <InsuranceProvider_Number type=\"string\">138057</InsuranceProvider_Number>\n        <InsuranceProvider_WholeName type=\"string\">国保</InsuranceProvider_WholeName>\n        <HealthInsuredPerson_Symbol type=\"string\">０１</HealthInsuredPerson_Symbol>\n        <HealthInsuredPerson_Number type=\"string\">１２３４５</HealthInsuredPerson_Number>\n        <Certificate_StartDate type=\"string\">2012-12-17</Certificate_StartDate>\n        <Certificate_ExpiredDate type=\"string\">9999-12-31</Certificate_ExpiredDate>\n\n        <PublicInsurance_Information type=\"array\">\n          <!-- 公費があれば child を追加。なければ空配列でもよい -->\n        </PublicInsurance_Information>\n      </HealthInsurance_Information>\n\n      <!-- 診療内容（array/child） -->\n      <Medical_Information type=\"array\">\n        <Medical_Information_child type=\"record\">\n          <Medical_Class type=\"string\">11</Medical_Class>\n          <Medical_Class_Name type=\"string\">Medical</Medical_Class_Name>\n          <Medical_Class_Number type=\"string\">1</Medical_Class_Number>\n          <Medication_info type=\"array\">\n            <Medication_info_child type=\"record\">\n              <Medication_Code type=\"string\">110000001</Medication_Code>\n              <Medication_Number type=\"string\">1</Medication_Number>\n            </Medication_info_child>\n          </Medication_info>\n        </Medical_Information_child>\n      </Medical_Information>\n    </Diagnosis_Information>\n  </acsimulatereq>\n</data>\n\n■補足（実装上のやり方）\n- “xml2形式の生成” を共通部品化する：\n  ・record：type=\"record\"\n  ・string：type=\"string\"\n  ・array：type=\"array\" と *_child(type=\"record\") を繰り返す\n- class 付きAPIは URL クエリに class を必ず付ける（patientlst2v2 と acsimulatev2 は class=01）\n\n------------------------------------------------------------\n【3】完了条件（受け入れ条件）\n------------------------------------------------------------\n- patientlst2v2：上のURL/Bodyで POST したとき、HTTP 200 で xmlio2 が返ること。\n  Api_Result が 00 になり、患者情報が返ること。（患者が無ければ “患者番号がありません” のメッセージ返却になること）\n- acsimulatev2：上のURL/Bodyで POST したとき、HTTP 200 で xmlio2 が返ること。\n  Api_Result が 00（または仕様どおりの業務エラー）として返り、HTTP 500 を出さないこと。\n- 送信した「最終URL」「Body全文」「ORCAのレスポンス全文」をログに残し、再現できること。\n\n以上を満たす修正PRを作ってください。",
    "model": "Codex CLI",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "createdAt": "2026-01-12T11:28:30.278Z",
    "updatedAt": "2026-01-12T11:28:30.278Z",
    "requiresTerminal": true,
    "createWorktree": true,
    "branchName": "task/task-1768217310278-4c12de",
    "baseBranch": "master",
    "useTmux": true,
    "singleMode": false,
    "aiCompetitionEntry": true,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": "comp-1768217310275-b8qjctgm",
    "aiCompetitionGroupName": "【プロンプトA】ORCA連携の既存不具合修正（patientlst2v2 / acsimulatev2 の Trial 500 を潰す）\n\nあなたは、ORCA連携（WebORCA Trial含む）のモダナイズ版Webクライアント実装を修正してください。\n狙いは「HTTP 500 を出さず、ORCA仕様どおりのレスポンス（Api_Result等）を返せる状態」に戻すことです。\n\n■前提（超重要）\n1) WebORCA向けは “APIパスの先頭に /api を付ける” 必要がある。\n   例：/api01rv2/... も /orca11/... も /api21/... も、WebORCAでは /api/ を前に付ける。\n2) 認証はHTTPの基本認証（Basic authentication）。ユーザID/パスワードは ORCA の職員（オペレータ）IDとパスワード。\n   （このプロジェクトでは既に Authorization: Basic ... を送っているので、そのままでOK）\n3) XMLは ORCA が要求する “型付きXML” を送る必要がある。\n   ここで言う型付きXMLとは、各タグに type=\"string\"/\"record\"/\"array\" が付く形式（xml2形式）。\n   配列は *_child を繰り返す形になる。\n\n■現状の問題（事実）\n- patientlst2v2 と acsimulatev2 を Trial に送ると HTTP 500 になる。\n- 現在送っているリクエストは、URLのクエリに class が付いていない。\n- さらに、Bodyが xml2形式（type属性付き）になっていない。\n\n■結論（修正方針）\nHTTP 500 の原因は「(a) class=01 が欠けている」「(b) リクエストXMLがxml2形式ではない」が最有力。\nこの2点をまず確実に直す。加えて、患者番号は数字文字列を使う（\"MOCK-500\" のような文字列は Trial/ORCA側で想定外の可能性が高い）。\n\n------------------------------------------------------------\n【1】patientlst2v2 の修正\n------------------------------------------------------------\n■正しいエンドポイント\n- WebORCA Trial へ送る完全URL例：\n  https://weborca-trial.orca.med.or.jp/api/api01rv2/patientlst2v2?class=01\n\n■HTTPメソッド\n- POST\n\n■ヘッダ\n- 既存どおりでOK：\n  Content-Type: application/xml; charset=UTF-8\n  Accept: application/xml\n  Authorization: Basic <既存のもの>\n\n■正しいBody（xml2形式。最小の形）\n<data>\n  <patientlst2req type=\"record\">\n    <Patient_ID_Information type=\"array\">\n      <Patient_ID_Information_child type=\"record\">\n        <Patient_ID type=\"string\">00012</Patient_ID>\n      </Patient_ID_Information_child>\n      <!-- 複数なら child を増やす（最大100件） -->\n    </Patient_ID_Information>\n  </patientlst2req>\n</data>\n\n■注意\n- “存在しない患者番号” でも、本来はHTTP 500ではなく「氏名に『患者番号がありません』等のメッセージを埋めて返す」仕様。\n  なので 500 が出るのは、ほぼリクエストの作り方の誤り。\n- まずは Trial 内に存在する「数字の患者番号」で試す。\n  （どうしても分からなければ、既に動いている acceptlstv2 等のレスポンスから Patient_ID を拾って再利用する）\n\n------------------------------------------------------------\n【2】acsimulatev2 の修正\n------------------------------------------------------------\n■正しいエンドポイント\n- WebORCA Trial へ送る完全URL例：\n  https://weborca-trial.orca.med.or.jp/api/api01rv2/acsimulatev2?class=01\n\n■HTTPメソッド\n- POST\n\n■ヘッダ\n- 既存どおりでOK：\n  Content-Type: application/xml; charset=UTF-8\n  Accept: application/xml\n  Authorization: Basic <既存のもの>\n\n■正しいBody（xml2形式。最小構成の考え方）\n- 送るべき最低限の“形”はこれ（type属性＋array/childを必ず守る）\n- 保険情報は「送らない」ことも理屈上は可能だが、Trialでは前回受診などに依存して失敗しやすい。\n  まずは保険情報も一緒に送る（patientlst2v2等のレスポンスから保険・公費情報を埋める）方が成功率が高い。\n\n<data>\n  <acsimulatereq type=\"record\">\n    <Patient_ID type=\"string\">03999</Patient_ID>\n    <Perform_Date type=\"string\">2026-01-11</Perform_Date>\n    <Perform_Time type=\"string\"></Perform_Time>\n    <Time_Class type=\"string\">0</Time_Class>\n\n    <Diagnosis_Information type=\"record\">\n      <Department_Code type=\"string\">01</Department_Code>\n\n      <!-- まずはこれを送る：保険・公費情報（record/array構造を守る）\n           値は patientlst2v2 / patientlst6v2 等の結果から埋める -->\n      <HealthInsurance_Information type=\"record\">\n        <InsuranceProvider_Class type=\"string\">060</InsuranceProvider_Class>\n        <InsuranceProvider_Number type=\"string\">138057</InsuranceProvider_Number>\n        <InsuranceProvider_WholeName type=\"string\">国保</InsuranceProvider_WholeName>\n        <HealthInsuredPerson_Symbol type=\"string\">０１</HealthInsuredPerson_Symbol>\n        <HealthInsuredPerson_Number type=\"string\">１２３４５</HealthInsuredPerson_Number>\n        <Certificate_StartDate type=\"string\">2012-12-17</Certificate_StartDate>\n        <Certificate_ExpiredDate type=\"string\">9999-12-31</Certificate_ExpiredDate>\n\n        <PublicInsurance_Information type=\"array\">\n          <!-- 公費があれば child を追加。なければ空配列でもよい -->\n        </PublicInsurance_Information>\n      </HealthInsurance_Information>\n\n      <!-- 診療内容（array/child） -->\n      <Medical_Information type=\"array\">\n        <Medical_Information_child type=\"record\">\n          <Medical_Class type=\"string\">11</Medical_Class>\n          <Medical_Class_Name type=\"string\">Medical</Medical_Class_Name>\n          <Medical_Class_Number type=\"string\">1</Medical_Class_Number>\n          <Medication_info type=\"array\">\n            <Medication_info_child type=\"record\">\n              <Medication_Code type=\"string\">110000001</Medication_Code>\n              <Medication_Number type=\"string\">1</Medication_Number>\n            </Medication_info_child>\n          </Medication_info>\n        </Medical_Information_child>\n      </Medical_Information>\n    </Diagnosis_Information>\n  </acsimulatereq>\n</data>\n\n■補足（実装上のやり方）\n- “xml2形式の生成” を共通部品化する：\n  ・record：type=\"record\"\n  ・string：type=\"string\"\n  ・array：type=\"array\" と *_child(type=\"record\") を繰り返す\n- class 付きAPIは URL クエリに class を必ず付ける（patientlst2v2 と acsimulatev2 は class=01）\n\n------------------------------------------------------------\n【3】完了条件（受け入れ条件）\n------------------------------------------------------------\n- patientlst2v2：上のURL/Bodyで POST したとき、HTTP 200 で xmlio2 が返ること。\n  Api_Result が 00 になり、患者情報が返ること。（患者が無ければ “患者番号がありません” のメッセージ返却になること）\n- acsimulatev2：上のURL/Bodyで POST したとき、HTTP 200 で xmlio2 が返ること。\n  Api_Result が 00（または仕様どおりの業務エラー）として返り、HTTP 500 を出さないこと。\n- 送信した「最終URL」「Body全文」「ORCAのレスポンス全文」をログに残し、再現できること。\n\n以上を満たす修正PRを作ってください。",
    "aiCompetitionMonitor": false,
    "monitorTargets": null,
    "scoringConfig": null,
    "worktreePath": ".worktrees/task-1768217310278-4c12de",
    "medal": "gold",
    "aiCompetitionScore": 91
  },
  {
    "id": "task-1768217507332-c6741a",
    "name": "CodexCLI1: 【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "model": "Codex CLI",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "createdAt": "2026-01-12T11:31:47.332Z",
    "updatedAt": "2026-01-12T11:31:47.332Z",
    "requiresTerminal": true,
    "createWorktree": true,
    "branchName": "task/task-1768217507332-c6741a",
    "baseBranch": "master",
    "useTmux": true,
    "singleMode": false,
    "aiCompetitionEntry": true,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": "comp-1768217507331-rkptnzgx",
    "aiCompetitionGroupName": "【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "aiCompetitionMonitor": false,
    "monitorTargets": null,
    "scoringConfig": null,
    "worktreePath": ".worktrees/task-1768217507332-c6741a"
  },
  {
    "id": "task-1768217525402-21cc3c",
    "name": "🔍Monitor: 【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "model": "codex",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "createdAt": "2026-01-12T11:32:05.403Z",
    "updatedAt": "2026-01-12T11:32:05.403Z",
    "requiresTerminal": true,
    "createWorktree": true,
    "branchName": "task/task-1768217525402-21cc3c",
    "baseBranch": "master",
    "useTmux": true,
    "singleMode": false,
    "aiCompetitionEntry": false,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": "comp-1768217507331-rkptnzgx",
    "aiCompetitionGroupName": "【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "aiCompetitionMonitor": true,
    "monitorTargets": [
      "task-1768217507332-c6741a"
    ],
    "scoringConfig": {
      "auditEnabled": false,
      "auditPrompt": "",
      "enabled": true,
      "prompt": "実用性、緻密性",
      "rubric": "medals",
      "model": "codex"
    },
    "autoEvaluationNotBefore": 1768217567331,
    "worktreePath": ".worktrees/task-1768217525402-21cc3c"
  }
]