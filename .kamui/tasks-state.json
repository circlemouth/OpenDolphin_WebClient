[
  {
    "id": "task-1768178988749-9aea39",
    "name": "対象ファイル: .kamui/apps/webclient-charts-compact-layout-plan-20260111.yaml\n\n36タスクまで完了しているはずだ。残るタスクの必要性について再評価し、不要なタスクは削除、進捗更新、タスクの集約化を行え。とくにsvg作成は不要な可能性があると思われる。",
    "model": "Codex CLI",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "branchName": null,
    "baseBranch": null,
    "worktreePath": null,
    "createWorktree": false,
    "createdAt": "2026-01-12T00:49:48.749Z",
    "updatedAt": "2026-01-12T00:49:48.749Z",
    "requiresTerminal": true,
    "bookmarked": false,
    "aiCompetitionEntry": false,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": null,
    "aiCompetitionGroupName": null,
    "autoEvaluationNotBefore": null,
    "useTmux": false,
    "taskType": null,
    "modelId": null,
    "latestVersion": null,
    "currentVersion": null,
    "installSteps": [],
    "installCommand": null,
    "createdAutomatically": false,
    "dependencies": []
  },
  {
    "id": "task-yaml-1rr1ie-src-webclient-ch",
    "name": "[webclient charts compact layout plan 20260111] 37_ユーティリティ導線統合確認\n期間: 01/13 12:00 - 01/14 12:00 / 優先度: medium / 緊急度: high / エージェント: cursor cli\n\n# 37 ユーティリティ導線統合確認\n\n- ドロワーと既存のショートカット導線が競合しないことを確認する。\n- DockedUtilityPanel の開閉で主要導線が隠れないことを確認する。\n- DockedUtilityPanel の状態遷移（compact/expanded）とフォーカス移動を結合検証する。\n- 診療操作/病名/処方/オーダー/文書の切替が期待通り動作することを確認する。\n\nYAML ID: src/webclient_charts_compact_layout_plan_20260111/integration/37_ユーティリティ導線統合確認.md",
    "model": "Codex CLI",
    "status": "completed",
    "importance": "medium",
    "urgency": "high",
    "branchName": "task/task-yaml-1rr1ie-src-webclient-ch",
    "baseBranch": "main",
    "worktreePath": null,
    "createWorktree": false,
    "createdAt": "2026-01-12T06:09:46.012Z",
    "updatedAt": "2026-01-12T08:56:54.954Z",
    "requiresTerminal": false,
    "bookmarked": false,
    "aiCompetitionEntry": false,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": null,
    "aiCompetitionGroupName": null,
    "autoEvaluationNotBefore": null,
    "useTmux": false,
    "taskType": "yaml-plan",
    "modelId": null,
    "latestVersion": null,
    "currentVersion": null,
    "installSteps": [],
    "installCommand": null,
    "createdAutomatically": false,
    "dependencies": [
      "task-yaml-8nkxbw-src-webclient-ch",
      "task-yaml-1s46k9m-src-webclient-ch"
    ]
  },
  {
    "id": "task-1768217507332-c6741a",
    "name": "CodexCLI1: 【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "model": "Codex CLI",
    "status": "working",
    "importance": "medium",
    "urgency": "medium",
    "createdAt": "2026-01-12T11:31:47.332Z",
    "updatedAt": "2026-01-12T11:31:47.332Z",
    "requiresTerminal": true,
    "createWorktree": true,
    "branchName": "task/task-1768217507332-c6741a",
    "baseBranch": "master",
    "useTmux": true,
    "singleMode": false,
    "aiCompetitionEntry": true,
    "aiCompetitionResult": null,
    "aiCompetitionGroupId": "comp-1768217507331-rkptnzgx",
    "aiCompetitionGroupName": "【プロンプトB】ORCA連携：新規API実装（不足分を追加。仕様・認証・形式までこの文面で完結）\n\nあなたは、モダナイズ版サーバーに「追加API」を実装してください。\nこの指示文の情報だけで、エンドポイント、認証、リクエスト形式、レスポンス形式を理解して実装できる状態にしてください。\n\n========================================\n0) 共通の前提（全APIに共通。ここを外すと動かない）\n========================================\n■URLの作り方（WebORCAとオンプレで違う）\n- オンプレ（日レセサーバ直）：http://<host>:8000/<APIパス>?<クエリ>\n- WebORCA（Trial含む）：<APIパス> の先頭に /api を付ける。\n  つまり WebORCAでは、/api/<APIパス> になる。\n\n例（患者基本情報取得）：\n- オンプレ：/api01rv2/patientgetv2?id=000001\n- WebORCA：/api/api01rv2/patientgetv2?id=000001\n\n※この“/api付与”は /api01rv2 だけでなく /orcaXX や /api21 など全APIパスに適用する。\n\n■認証\n- デフォルトは HTTPの基本認証（Basic authentication）。\n- Basic認証のユーザ/パスワードは ORCA の職員情報に設定されたオペレータIDとパスワード。\n- もし接続先glserverでSSLクライアント認証が有効なら、クライアント証明書が必要（ただし本実装では現状のBasicを維持し、証明書対応は“オプション”として設計だけ可能にする）。\n\n■データ形式（超重要）\n- 多くのAPIは “xml2形式” のXMLを使う。\n  これは、タグに type=\"string\"/\"record\"/\"array\" が付く型付きXML。\n  配列は *_child を繰り返す。\n\n■ヘッダ（基本）\n- Content-Type: application/xml; charset=UTF-8\n- Accept: application/xml\n- Authorization: Basic <既存の実装に従う>\n- 例外：処方箋印刷API（prescriptionv2）はレスポンスがJSONになる（既存実装側で考慮済みならOK）\n\n========================================\n1) 追加実装するAPI（患者まわり）\n========================================\n\n(1) 患者基本情報の取得（patientgetv2）\n- 目的：患者番号を指定して、患者の基本情報を1人分取得する。\n- Method：GET\n- APIパス：/api01rv2/patientgetv2\n- クエリ：\n  ・id=xxxx（患者番号）\n  ・format=json（任意。指定するとJSONでも返る）\n- WebORCAの完全URL例：\n  https://<weborca-host>/api/api01rv2/patientgetv2?id=00012\n- 返却：通常は xml2形式（xmlio2）。format=json 指定時はJSON。\n\n(2) 患者登録・更新・削除・保険追加（patientmodv2）\n- 目的：患者の新規登録/更新/削除、または保険追加をORCA側へ反映する。\n- Method：POST\n- APIパス：/orca12/patientmodv2\n- クエリ：class を必ず付ける\n  ・class=01 患者登録\n  ・class=02 患者情報更新\n  ・class=03 患者情報削除\n  ・class=04 保険追加（xml2のみ）\n- Body：xml2形式。最小の“形”はこうなる（項目は用途に応じて増やす）\n  <data>\n    <patientmodreq type=\"record\">\n      <Mod_Key type=\"string\">2</Mod_Key>\n      <Patient_ID type=\"string\">*</Patient_ID>\n      <WholeName type=\"string\">日医 太郎</WholeName>\n      <WholeName_inKana type=\"string\">ニチイ タロウ</WholeName_inKana>\n      <BirthDate type=\"string\">1970-01-01</BirthDate>\n      <Sex type=\"string\">1</Sex>\n      ...\n    </patientmodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず読んで呼び出し元へ返す。\n\n(3) 患者メモ取得（patientlst7v2）\n- 目的：患者のメモ（メモ2/メモ1）を取得する。既定はメモ2。メモ1が欲しいときだけ Memo_Class=1。\n- Method：POST\n- APIパス：/api01rv2/patientlst7v2\n- クエリ：基本なし（Request_NumberはBody側）\n- Body（xml2形式）\n  <data>\n    <patientlst7req type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>\n      <Patient_ID type=\"string\">161</Patient_ID>\n      <Base_Date type=\"string\">2018-11-13</Base_Date>\n      <Department_Code type=\"string\"></Department_Code>\n      <Memo_Class type=\"string\"></Memo_Class>\n    </patientlst7req>\n  </data>\n- 返却：xml2形式（xmlio2）。最大10件。\n\n(4) 患者メモ登録（patientmemomodv2）\n- 目的：患者番号＋登録日＋診療科で、メモ1/メモ2を登録・更新・削除する。\n- Method：POST\n- APIパス：/orca06/patientmemomodv2\n- クエリ：なし（操作は Request_Number で分岐）\n- Body（xml2形式）\n  <data>\n    <patient_memomodreq type=\"record\">\n      <Request_Number type=\"string\">01</Request_Number>   ← 01:登録 / 02:更新 / 03:削除\n      <Patient_ID type=\"string\">1</Patient_ID>\n      <Perform_Date type=\"string\">2025-08-25</Perform_Date> ← 未設定ならシステム日付\n      <Department_Code type=\"string\">01</Department_Code>   ← 登録・更新は必須。00は全科\n      <Memo_Class type=\"string\">2</Memo_Class>              ← 1:メモ1 / 2:メモ2（未設定は2）\n      <Patient_Memo type=\"string\">テストメモ</Patient_Memo> ← 登録・更新は必須\n    </patient_memomodreq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result と Api_Result_Message を必ず呼び出し元へ返す。\n\n========================================\n2) 追加実装するAPI（病名まわり）\n========================================\n\n(1) 患者病名情報の返却（diseasegetv2）\n- 目的：患者の病名一覧をORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/diseasegetv2\n- クエリ：class=01\n- Body（xml2形式）\n  <data>\n    <disease_inforeq type=\"record\">\n      <Patient_ID type=\"string\">00012</Patient_ID>\n      <Base_Date type=\"string\">2012-05</Base_Date>  ← 基準月\n    </disease_inforeq>\n  </data>\n- 返却：xml2形式（xmlio2）。Api_Result を必ず判定。\n\n(2) 患者病名登録２（diseasev3）\n- 目的：患者の病名データを追加・変更・削除する。\n- Method：POST\n- APIパス：/orca22/diseasev3\n- クエリ：class=01（患者病名登録）\n- Body：xml2形式。最小の“形”はこの構造（Disease_Information が array/child になる）\n  <data>\n    <diseasereq type=\"record\">\n      <Patient_ID type=\"string\">07009</Patient_ID>\n      <Base_Month type=\"string\"></Base_Month>\n      <Perform_Date type=\"string\">2018-05-01</Perform_Date>\n      <Perform_Time type=\"string\"></Perform_Time>\n      <Diagnosis_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n      </Diagnosis_Information>\n      <Disease_Information type=\"array\">\n        <Disease_Information_child type=\"record\">\n          <!-- ここに病名コードや病名、開始日などを入れる。\n               追加・変更・削除の指定もこの child 側の項目で行う設計。 -->\n        </Disease_Information_child>\n      </Disease_Information>\n    </diseasereq>\n  </data>\n- 注意：旧方式（diseasev2）は将来廃止予定の扱いなので、新規実装は diseasev3 を標準にする。\n\n========================================\n3) 追加実装するAPI（診療まわり）\n========================================\n\n(1) 診療情報の返却（medicalgetv2）\n- 目的：受診履歴や、特定日の診療内容などをORCAから取得する。\n- Method：POST\n- APIパス：/api01rv2/medicalgetv2\n- クエリ：class を使い分ける\n  ・class=01 受診履歴一覧取得\n  ・class=02 診療行為剤内容詳細取得\n  ・class=03 診療月診療コード情報取得\n  ・class=04 診療区分別剤点数取得（xml2のみ）\n- Body（xml2形式。例：class=01 の形）\n  <data>\n    <medicalgetreq type=\"record\">\n      <InOut type=\"string\">I</InOut>\n      <Patient_ID type=\"string\">12</Patient_ID>\n      <Perform_Date type=\"string\">2014-01-06</Perform_Date>\n      <For_Months type=\"string\">12</For_Months>\n      <Medical_Information type=\"record\">\n        <Department_Code type=\"string\">01</Department_Code>\n        <Sequential_Number type=\"string\"></Sequential_Number>\n        <Insurance_Combination_Number type=\"string\">0002</Insurance_Combination_Number>\n      </Medical_Information>\n    </medicalgetreq>\n  </data>\n- 返却：xml2形式（xmlio2）\n\n(2) 中途終了データ作成（medicalmodv2）\n- 目的：診療データ（診療行為など）をORCAに登録・変更・削除する（会計やレセプトの元になるデータ）。\n- Method：POST\n- APIパス：/api21/medicalmodv2\n- クエリ：class を必ず付ける\n  ・class=01 登録\n  ・class=02 削除\n  ・class=03 変更\n  ・class=04 外来追加\n- 重要な仕様：\n  ・class=01 は “診療データ＋病名データ” どちらも送れる（必要に応じて片方だけでも可）\n  ・class=02/03/04 は診療データのみ（病名を送っても無効）\n- Body：xml2形式。最小でも Patient_ID / Perform_Date / Department_Code / Physician_Code / 保険情報 / 診療行為の配列が必要になる想定。\n  （ここは業務ロジックに依存するので、まず“送れる器”＝xml2構造を崩さず送信できる実装を作り、データの中身は呼び出し側が埋める設計にする）\n\n========================================\n4) 受け入れ条件（完成の定義）\n========================================\n- 上記の各APIについて\n  1) WebORCAでは /api 付与が漏れない\n  2) classが必要なものは必ずURLクエリに付く\n  3) xml2形式（type属性、array/child）が必ず守られる\n  4) レスポンスの Api_Result / Api_Result_Message を必ず上位へ返す\n- 送信時に「最終URL」「ヘッダ（機微はマスク）」「Body全文」「レスポンス全文」をログに残し、障害調査できる状態にする\n- 処方箋印刷API（prescriptionv2）のように “レスポンスがJSONのAPIが混ざる” 前提で、レスポンスの Content-Type を見てパースを分ける共通処理を持つ\n\nこの条件を満たす実装PRを作ってください。",
    "aiCompetitionMonitor": false,
    "monitorTargets": null,
    "scoringConfig": null,
    "worktreePath": ".worktrees/task-1768217507332-c6741a",
    "medal": "silver",
    "aiCompetitionScore": 84
  }
]